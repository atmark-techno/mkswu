#!/bin/sh

# SC2039: local is ok for dash and busybox ash
# SC1090: non-constant source directives
# SC2165/SC2167: use same variable for nested loops
# shellcheck disable=SC2039,SC1090,SC2165,SC2167

if command -v gettext >/dev/null; then
	_gettext() { TEXTDOMAINDIR="$TEXTDOMAINDIR" TEXTDOMAIN=mkswu gettext -- "$@"; }
else
	_gettext() { printf -- "%s" "$@"; }
fi

printmsg() {
	local level=$1
	shift
	[ "$VERBOSE" -lt "$level" ] && return

	if [ "$#" = "0" ] || [ -z "$1" ]; then
		echo
		return
	fi

	local fmt="$1"
	shift
	printf -- "$(_gettext "$fmt")\n" "$@"
}

error() {
	if [ "$#" = "0" ] || [ -z "$1" ]; then
		error "Error called without format string!"
		exit 1
	fi

	local fmt="$1"
	shift
	printf -- "ERROR: $(_gettext "$fmt")\n" "$@" >&2
	exit 1
}

warning() {
	printmsg 1 "$@" >&2
}

info() {
	printmsg 2 "$@"
}

trace() {
	printmsg 3 "$@" >&2
}

debug() {
	printmsg 4 "$@" >&2
}

# dash doesn't handle read -s
# and even if it did we wouldn't have gettext wrapping
# so provide our own helper
prompt() {
	local var="$1"
	local prompt_fmt="$2"
	shift 2

	if [ -n "$PASS" ]; then
		trap "stty echo" EXIT INT QUIT
		stty -echo
	fi

	printf -- "$(_gettext "$prompt_fmt") " "$@"
	read -r "$var"

	if [ -n "$PASS" ]; then
		stty echo
		trap "" EXIT INT QUIT
		echo
	fi
}

usage() {
	info "Usage: %s [opts] desc [desc...]" "$0"
	info
	info "Options:"
	info "  -c, --config <conf>     path to config (default ~/mkswu/mkswu.conf)"
	info "  -o, --out <out.swu>     path to output file (default from first desc's name)"
	info "  --init                  walk through initial key and first image generation"
	info "  --import                import current directory's config and keys into config dir"
	info "  --genkey                toggle key generation mode (see below for suboptions)"
	info "  --version               print version and exit"
	info "  desc                    image description file(s), if multiple are given"
	info "                          then the generated image will merge all the contents"
	info
	info "desc file syntax:"
	info "  descriptions are imperative declarations building an image, the following"
	info "  commands available (see README for details):"
	info "  - swdesc_boot <bootfile>"
	info "  - swdesc_tar <tar_file> [--dest <dest>]"
	info "  - swdesc_files [--basedir <basedir>] [--dest <dest>] <files>"
	info "  - swdesc_command '<cmd>'"
	info "  - swdesc_script <script>"
	info "  - swdesc_exec <file> '<cmd>' (file is \$1 in command)"
	info "  - swdesc_embed_container <image_archive>"
	info "  - swdesc_usb_container <image_archive>"
	info "  - swdesc_pull_container <image_url>"
	info
	info "In most cases --version <component> <version> should be set,"
	info "<component> must be extra_os.* in order to update rootfs"
	info
	info "Key generation options:"
	info "  --cn          common name for key (mandatory for signing key)"
	info "  --plain       generate signing key without encryption"
	info "  --aes         generate aes key instead of default rsa key pair"
}

write_line() {
	local line
	for line; do
		[ -z "$line" ] && continue
		printf "%*s%s\n" "$((0${line:+1}?indent:0))" "" "$line"
	done
}

reindent() {
	local padding
	padding=$(printf "%*s" "${indent:-0}" "")

	sed -e "s/^/$padding/" "$@"
}


link() {
	local src="$1"
	local dest="$2"
	local existing

	track_used "$dest"

	src=$(readlink -e "$src") || error "Cannot find source file: %s" "$1"

	if [ -h "$dest" ]; then
		existing=$(readlink "$dest")
		[ "$src" = "$existing" ] && return
		rm -f "$dest" || error "Could not remove previous link at %s" "$dest"
	elif [ -e "$dest" ]; then
		cmp "$src" "$dest" > /dev/null && return
		rm -f "$dest" || error "Could not remove previous file at %s" "$dest"
	fi

	# files with hardlinks will mess up the order within the cpio,
	# and thus change the order in which components are installed
	# (e.g. rootfs after post script...)
	# workaround by copying file (reflinks are ok) instead if required
	if [ "$(stat -c %h "$src")" != 1 ]; then
		cp --reflink=auto "$src" "$dest" || error "Could not copy %s to %s" "$src" "$dest"
	else
		ln -s "$(readlink -e "$src")" "$dest" || error "Could not link %s to %s" "$dest" "$src"
	fi
}

gen_iv() {
	openssl rand -hex 16
}

encrypt_file() {
	local src="$1"
	local dest="$2"
	local iv

	iv=$(gen_iv) || return 1
	openssl enc -aes-256-cbc -in "$src" -out "$dest" \
		-K "$ENCRYPT_KEY" -iv "$iv" || return 1

	# Note if anyone needs debugging, can be decrypted with:
	# openssl enc -aes-256-cbc -d -in encrypted_file -out decrypted_file -K key -iv iv

	printf %s "$iv"
}

setup_encryption() {
	[ -z "$ENCRYPT_KEYFILE" ] && return
	[ -e "$ENCRYPT_KEYFILE" ] \
		|| error "AES encryption key %s was set but not found.\nPlease create it with genkey.sh --aes" \
			"$ENCRYPT_KEYFILE"
	ENCRYPT_KEY=$(cat "$ENCRYPT_KEYFILE")
	# XXX if sw-description gets encrypted, its iv is here
	ENCRYPT_KEY="${ENCRYPT_KEY% *}"
}

compress() {
	local file_src="$1"
	local file_out="$2"

	track_used "$file_src"

	# zstd copies timestamp and test -nt/-ot are strict,
	# "! newer than" is equivalent to "older or equal than"
	[ -e "$file_out" ] && ! [ "$file_src" -nt "$file_out" ] && return

	zstd -q -10 "$file_src" -o "$file_out.tmp" \
		|| error "failed to compress %s" "$file_src"
	mv "$file_out.tmp" "$file_out"
}

write_entry_stdout() {
	local file_src="$1"
	local file="${file_src##*/}"
	local file_out="$OUTDIR/$file"
	local compress="$compress"
	local install_if="$install_if"
	shift
	local sha256 iv err

	trace "Processing $file"
	[ -e "$file_src" ] || error "Missing source file: %s" "$file_src"

	if [ -n "$compress" ]; then
		# Check if already compressed
		case "$file" in
		*.tar.*)
			if [ "$compress" = force ]; then
				# Force decompression through swupdate.
				# Only gzip and zstd are supported
				case "$file" in
				*.gz) compress=zlib;;
				*.zst) compress=zstd;;
				*) compress="";;
				esac
			else
				# archive handle will handle it
				compress=""
			fi
			;;
		*.apk)
			# already compressed
			compress=""
			;;
		*.zst)
			compress=zstd
			;;
		*)
			# do not compress files < 128 bytes
			if [ "$(stat -c "%s" "$file_src")" -lt 128 ]; then
				compress=""
			else
				compress=zstd
				file="$file.zst"
				file_out="$file_out.zst"
				compress "$file_src" "$file_out"
				file_src="$file_out"
			fi
			;;
		esac
	fi

	if [ -n "$ENCRYPT_KEY" ] && [ -s "$file_src" ]; then
		file="$file.enc"
		file_out="$file_out.enc"
		iv=$(encrypt_file "$file_src" "$file_out") \
			|| error "failed to encrypt %s" "$file_src"
		file_src="$file_out"

	fi

	printf %s "$FILES" | grep -q -x "$file" || FILES="$FILES
$file"

	[ "$file_src" = "$file_out" ] && track_used "$file_out" \
		|| link "$file_src" "$file_out"

	track_used "$file_out.sha256sum"

	if [ -e "$file_out.sha256sum" ] && [ "$file_out.sha256sum" -nt "$file_out" ]; then
		sha256=$(cat "$file_out.sha256sum")
	else
		sha256=$(sha256sum < "$file_out") \
			|| error "Checksumming %s failed" "$file_out"
		sha256=${sha256%% *}
		printf "%s\n" "$sha256" > "$file_out.sha256sum"
	fi


	write_line "{"
	indent=$((indent+2))
	write_line "filename = \"$file\";"
	if [ -n "$component" ]; then
		[ -n "$version" ] || error "component %s was set with empty version" "$component"
		if [ -z "$install_if" ]; then
			case "$component" in
			boot) install_if="different";;
			*) install_if="higher";;
			esac
		fi
		case "$install_if" in
		higher)
			local max
			# handle only x.y.z.t or x.y.z-t
			printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)?(\.[0-9]+)?(\.[0-9]*|-[A-Za-z0-9.]+)?$' \
				|| error "Version %s must be x.y.z.t (numbers < 65536 only) or x.y.z-t (x-z numbers only)" "$version"
			# ... and check for max values
			if [ "${version%-*}" = "${version}" ]; then
				# only dots, "old style version" valid for 16 bits, but now overflow
				# falls back to semver which is signed int but only for 3 elements
				if printf %s "${version}" | grep -qE '\..*\..*\.'; then
					max=65535
				else
					max=2147483647
				fi
				# base_os must be x.y.z-t format to avoid surprises
				# with semver prerelease field filtering
				[ "$component" = "base_os" ] \
					&& error "base_os version %s must be in x[.y[.z]]-t format" "$version"
			else
				# semver, signed int
				max=2147483647
			fi
			err=$(printf %s "$version" | tr '.-' '\n' | awk '
				/^[0-9]+$/ && $1 > '$max' {
					print "1 " $1;
					exit
				}
				/[0-9][a-zA-Z]|[a-zA-Z][0-9]/ {
					print "2 " $1;
					exit
				}')
			case "$err" in
			1\ *) error "version check failed for %s: %s must be <= %s" "$version" "${err#* }" "$max";;
			2\ *) error "version check failed for %s: %s must not mix alpha and digits" "$version" "${err#* }";;
			esac
			;;
		different)
			# different still goes through integer parsing, but is more relaxed
			# as different ordering does not matter, and pure lexicographical
			# is also allowed... Who said painful ?...
			if printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)?(\.[0-9]+)?(\.[0-9]*|-[A-Z  a-z0-9.-]+)?$'; then
				# same max check as above without mixed alnum check
				local max=2147483647
				[ "${version%-*}" = "${version}" ] \
					&& printf %s "${version}" | grep -qE '\..*\..*\.' \
					&& max=65535
				err=$(printf %s "$version" | tr '.-' '\n' | awk '
					/^[0-9]+$/ && $1 > '$max' {
						print "1 " $1;
						exit
					}')
				case "$err" in
				1\ *) error "version check failed for %s: %s must be <= %s" "$version" "${err#* }" "$max";;
				esac
			else
				# Oh, and semvers with + are also identical!...
				printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)?(\.[0-9]+)?(\.[0-9]*|-[A-Z  a-z0-9.-+]+)?$' \
					&& error "metadata (+ part) in semver are ignored by swupdate, please use something else than %s"
			fi
	 ;;
		*) error "install_if must be higher or different";;
		esac
		[ "${component#* }" = "$component" ] || error "component must not contain spaces (%s)" "$component"
		[ "${version#* }" = "$version" ] || error "version must not contain spaces (%s = %s)" "$component" "$version"
		write_line "name = \"$component\";" \
			   "version = \"$version\";" \
			   "install-if-${install_if} = true;"

		# remember version for scripts
		printf "%s\n" "$component $version $install_if ${board:-*}" >> "$OUTDIR/sw-description-versions"
	elif [ -n "$version" ]; then
		error "version %s was set without associated component" "$version"
	fi
	if [ -n "$main_version" ]; then
		[ -n "$component" ] && [ -n "$version" ] \
			|| error "use as main version requested but component/version not set?"
		write_line "# MAIN_COMPONENT $component" \
			   "# MAIN_VERSION $version"
	fi
	[ -n "$compress" ] && write_line "compressed = \"$compress\";"
	[ -n "$iv" ] && write_line "encrypted = true;" "ivt = \"$iv\";"
	write_line "installed-directly = true;"
	write_line "sha256 = \"$sha256\";"
	write_line "$@"

	indent=$((indent-2))
	write_line "},"
}

write_entry() {
	local outfile="$OUTDIR/sw-description-$1${board:+-$board}"
	shift

	# Running init here allows .desc files to override key elements
	# before the first swdesc_* statement
	if [ -n "$FIRST_SWDESC_INIT" ]; then
		FIRST_SWDESC_INIT=""
		setup_encryption
		embedded_preinstall_script
	fi

	write_entry_stdout "$@" >> "$outfile"
}

parse_swdesc() {
	local ARG SKIP=0 NOPARSE=""

	# first argument tells us what to parse for
	local CMD="$1"
	shift

	for ARG; do
		shift
		# skip previously used argument
		# using a for loop means we can't shift ahead
		if [ "$SKIP" -gt 0 ]; then
			SKIP=$((SKIP-1))
			continue
		fi
		case "$NOPARSE$ARG" in
		"-b"|"--board")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			board="$1"
			SKIP=1
			;;
		"-v"|"--version")
			[ $# -lt 2 ] && error "%s requires <component> <version> arguments" "$ARG"
			component="$1"
			version="$2"
			SKIP=2
			;;
		"--main-version")
			main_version=1
			SKIP=0
			;;
		"--install-if")
			install_if="$1"
			case "$install_if" in
			higher|different) ;;
			*) error "--install-if must be higher or different";;
			esac
			SKIP=1
			;;
		"--preserve-attributes")
			[ "$CMD" = "tar" ] || [ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files and swdesc_tar" "$ARG"
			preserve_attributes=1
			SKIP=0
			;;
		"-d"|"--dest")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			[ "$CMD" = "tar" ] || [ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files and swdesc_tar" "$ARG"
			dest="$1"
			SKIP=1
			;;
		"--basedir")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			[ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files" "$ARG"
			basedir="$1"
			SKIP=1
			;;
		--)
			# we can't break loop or we would reorder previously seen
			# arguments with the rest: just tell parsing to not parse anymore
			# setting NOPARSE here will make the case always fall to last element
			NOPARSE=1
			;;
		"-"*)
			error "%s is not a known %s argument" "$ARG" "swdesc_$CMD"
			;;
		*)
			set -- "$@" "$ARG"
			;;
		esac
	done
	case "$CMD" in
	boot)
		[ $# -eq 0 ] && [ -n "$BOOT" ] && return
		[ $# -eq 1 ] || error "Usage: swdesc_boot [options] boot_file"
		BOOT="$1"
		;;
	tar)
		[ $# -eq 0 ] && [ -n "$source" ] && return
		[ $# -eq 1 ] || error "Usage: swdesc_tar [options] file.tar"
		source="$1"
		;;
	files)
		[ $# -eq 0 ] && [ -n "$file" ] && [ -n "$tarfiles_src" ] && return
		[ $# -ge 1 ] || error "Usage: swdesc_files [options] file [files...]"
		tarfiles_src="$(printf "%s\n" "$@")"
		;;
	command)
		[ $# -eq 0 ] && [ -n "$cmd" ] && return
		[ $# -ge 1 ] || error "Usage: swdesc_command [options] cmd [cmd..]"
		cmd=""
		for ARG; do
			cmd="${cmd:+$cmd && }$ARG"
		done
		;;
	script)
		[ $# -eq 0 ] && [ -n "$script" ] && return
		[ $# -eq 1 ] || error "Usage: swdesc_script [options] script"
		script="$1"
		;;
	exec)
		[ $# -eq 0 ] && [ -n "$cmd" ] && [ -n "$file" ] && return
		[ $# -ge 2 ] || error "Usage: swdesc_exec [options] file command"
		file="$1"
		shift
		cmd=""
		for ARG; do
			cmd="${cmd:+$cmd && }$ARG"
		done
		;;
	*container)
		[ $# -eq 0 ] && [ -n "$image" ] && return
		[ $# -eq 1 ] || error "Usage: %s [options] image" "swdesc_$CMD"
		image="$1"
		;;
	*)
		error "Unhandled command %s" "$CMD"
		;;
	esac
}

pad_boot() {
	local file="${BOOT##*/}"
	local src="$BOOT"
	local size

	BOOT_SIZE=$(numfmt --from=iec "$BOOT_SIZE")
	BOOT="$OUTDIR/$file"

	if [ "$src" -ot "$BOOT" ]; then
		size=$(stat -c "%s" "$BOOT")
		if [ "$size" -eq "$BOOT_SIZE" ]; then
			# already up to date
			return
		fi
	fi

	size=$(stat -c "%s" "$src") || error "Cannot stat boot file: %s" "$src"
	if [ "$size" -gt "$BOOT_SIZE" ]; then
		error "BOOT_SIZE set smaller than boot file actual size"
	fi
	rm -f "$BOOT"
	cp "$src" "$BOOT"
	truncate -s "$BOOT_SIZE" "$BOOT"
}

swdesc_boot() {
	local BOOT="$BOOT" component=boot version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc boot "$@"

	[ -n "$BOOT_SIZE" ] && pad_boot

	[ "$component" = "boot" ] \
		|| error "Version component for swdesc_boot must be set to boot"
	if [ -z "$version" ]; then
		version=$(strings "$BOOT" \
				| grep -m1 -oE '20[0-9]{2}.[0-1][0-9]-[0-9a-zA-Z.-]*') \
			|| error "Could not guess boot version in %s" "$BOOT"
	fi

	write_entry images "$BOOT" "type = \"raw\";" \
		"device = \"/dev/swupdate_bootdev\";"
}

swdesc_tar() {
	local source="$source" dest="$dest"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"
	local preserve_attributes="$preserve_attributes"
	local target="/target"

	parse_swdesc tar "$@"

	case "$DEBUG_SWDESC" in
	*DEBUG_SKIP_SCRIPTS*) target="";;
	esac
	case "$component" in
	base_os|extra_os*)
		dest="${dest:-/}"
		if [ "${dest#/}" = "$dest" ]; then
			error "OS update must have an absolute dest (was: %s)" "$dest"
		fi
		;;
	*)
		dest="${dest:-/var/app/rollback/volumes}"
		case "$dest" in
		/var/app/rollback/volumes*|/var/app/volumes*)
			# ok
			;;
		/*)
			[ -n "$target" ] \
				&& error "OS is only writable for base/extra_os updates and dest (%s) is not within volumes" "$dest"
			;;
		..*|*/../*|*/..)
			error ".. is not allowed in destination path for volume update"
			;;
		*)
			dest="/var/app/rollback/volumes/$dest"
			;;
		esac
	esac

	# it doesn't make sense to not set preserve_attributes
	# for base_os updates: fix it
	if [ "$component" = "base_os" ] \
	    && [ -z "$preserve_attributes" ]; then
		info "Warning: automatically setting --preserve-attributes for base_os update" >&2
		preserve_attributes=1
	fi
	write_entry images "$source" "type = \"archive\";" \
		"path = \"$target$dest\";" \
		"properties: { create-destination = \"true\"; };" \
		"${preserve_attributes:+preserve-attributes = true;}"
}

set_file_from_content() {
	local content="$*"

	file="$(printf %s "$content" | tr -c '[:alnum:]' '_')"
	if [ "${#file}" -gt 40 ]; then
		file="$(printf %s "$file" | head -c 20)..$(printf %s "$file" | tail -c 20)"
	fi
	file="${file}_$(printf %s "$content" | sha1sum | cut -d' ' -f1)"
	file="$OUTDIR/${file}"
}

swdesc_files() {
	local file="$file" dest="$dest" basedir="$basedir"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"
	local preserve_attributes="$preserve_attributes"
	local tarfile tarfile_raw tarfiles_src="$tarfiles_src"
	local mtime=0
	local IFS="
"
	parse_swdesc files "$@"

	set -- $tarfiles_src
	# XXX temporary warning -- until when?
	[ -e "$1" ] || error "%s does not exist\nplease note swdesc_files syntax changed and no longer requires setting a name" "$1"
	if [ -z "$basedir" ]; then
		[ -d "$1" ] && basedir="$1" || basedir=$(dirname "$1")
	fi

	set --
	for tarfile_raw in $tarfiles_src; do
		tarfile=$(realpath -e -s --relative-to="$basedir" "$tarfile_raw") \
			|| error "%s does not exist" "$tarfile_raw"
		[ "${tarfile#../}" = "$tarfile" ] \
			|| error "%s is not inside %s" "$tarfile_raw" "$basedir"

		mtime=$({ printf "%s\n" "$mtime"; find "$tarfile_raw" -exec stat -c "%Y" {} +; } \
				| awk '$1 > max { max=$1 } END { print max }')
		set -- "$@" "$tarfile"
	done

	set_file_from_content "$basedir" "$dest" "$@"
	file="$file.tar"

	if ! [ -e "$file" ] \
	    || [ "$mtime" -gt "$(stat -c "%Y" "$file")" ]; then
		tar -cf "$file" -C "$basedir" "$@" \
			|| error "Could not create tar for %s" "$file"
	fi

	swdesc_tar "$file"
}


shell_quote() {
	# sh-compliant quote function from http://www.etalabs.net/sh_tricks.html
	printf %s "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/"
}
conf_quote() {
	# Double backslashes, escape double-quotes, replace newlines by \n
	# (the last operation requires reading all input into patternspace first)
	printf %s "$1" | sed  ':a;$!N;$!ba;s/\\/\\\\/g;s/"/\\"/g;s/\n/\\n/g'
}

swdesc_exec_nochroot() {
	local file="$file" cmd="$cmd"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc exec "$@"

	[ ! -s "$file" ] || [ "$cmd" != "${cmd#*\$1}" ] \
		|| error 'Using swdesc_exec_nochroot with a non-empty file, but not referring to it with $1'

	cmd="sh -c $(shell_quote "$cmd") --"

	write_entry files "$file" "type = \"exec\";" \
		"properties: {" \
		"  cmd: \"$(conf_quote "$cmd")\"" "}"
}

swdesc_exec() {
	local file="$file" cmd="$cmd" chroot_cmd
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc exec "$@"

	[ ! -s "$file" ] || [ "$cmd" != "${cmd#*\$1}" ] \
		|| error 'Using swdesc_exec with a non-empty file, but not referring to it with $1'

	case "$component" in
	base_os|extra_os*)
		chroot_cmd="podman run --net=host --rm --rootfs /target sh -c $(shell_quote "$cmd") -- "
		;;
	*)
		# If target is read-only we need special handling to run (silly podman tries
		# to write to / otherwise) but keep volumes writable
		chroot_cmd="podman run --net=host --rm --read-only -v /target/var/app/volumes:/var/app/volumes"
		chroot_cmd="$chroot_cmd -v /target/var/app/rollback/volumes:/var/app/rollback/volumes"
		chroot_cmd="$chroot_cmd --rootfs /target sh -c $(shell_quote "$cmd") -- "
		;;
	esac

	write_entry files "$file" "type = \"exec\";" \
		"properties: {" \
		"  cmd: \"$(conf_quote "$chroot_cmd")\"" "}"
}

swdesc_command() {
	local cmd="$cmd" file
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc command "$@"

	set_file_from_content "$cmd"
	[ -e "$file" ] || : > "$file"

	swdesc_exec
}

swdesc_command_nochroot() {
	local cmd="$cmd" file
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc command "$@"

	set_file_from_content "$cmd"
	[ -e "$file" ] || : > "$file"

	swdesc_exec_nochroot
}

swdesc_script() {
	local script="$script"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc script "$@"

	swdesc_exec "$script" 'sh $1'
}

swdesc_script_nochroot() {
	local script="$script"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc script "$@"

	swdesc_exec_nochroot "$script" 'sh $1'
}


swdesc_embed_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc embed_container "$@"

	swdesc_exec_nochroot "$image" '${TMPDIR:-/var/tmp}/scripts/podman_update --storage /target/var/lib/containers/storage_readonly -l $1'
}

swdesc_pull_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc pull_container "$@"

	swdesc_command_nochroot '${TMPDIR:-/var/tmp}/scripts/podman_update --storage /target/var/lib/containers/storage_readonly "'"$image"'"'
}

swdesc_usb_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if"

	parse_swdesc usb_container "$@"

	local image_usb=${image##*/}
	if [ "${image_usb%.tar.*}" != "$image_usb" ]; then
		info "Warning: podman does not handle compressed container images without an extra uncompressed copy"
		info "you might want to keep the archive as simple .tar"
	fi
	link "$image" "$OUTDIR/$image_usb"
	sign "$image_usb"
	COPY_USB="${COPY_USB:+$COPY_USB }$(shell_quote "$(realpath "$image")")"
	COPY_USB="$COPY_USB $(shell_quote "$(realpath "$OUTDIR/$image_usb.sig")")"

	swdesc_command_nochroot '${TMPDIR:-/var/tmp}/scripts/podman_update --storage /target/var/lib/containers/storage_readonly --pubkey /etc/swupdate.pem -l '"/mnt/$image_usb"
}

embedded_preinstall_script() {
	local f update=""
	local component="" version="" board="" main_version="" install_if=""

	[ -e "$OUTDIR/scripts.tar" ] || update=1
	for f in "$EMBEDDED_SCRIPTS_DIR"/*; do
		if [ "$f" -nt "$OUTDIR/scripts.tar" ]; then
			update=1
			break
		fi
	done
	if [ -n "$update" ]; then
		tar -cf "$OUTDIR/scripts.tar" -C "$EMBEDDED_SCRIPTS_DIR" . \
			|| error "Could not create script.tar"
	fi


	swdesc_exec_nochroot "$OUTDIR/scripts.tar" 'rm -rf ${TMPDIR:-/var/tmp}/scripts' \
			'mkdir ${TMPDIR:-/var/tmp}/scripts' \
			'cd ${TMPDIR:-/var/tmp}/scripts' \
			'tar x -vf $1' "./$PRE_SCRIPT"
}

embedded_postinstall_script() {
	local component="" version="" board="" main_version="" install_if=""
	swdesc_script_nochroot "$POST_SCRIPT"
}

write_sw_desc() {
	local indent=4
	local file line section board=""
	local board_hwcompat board_normalize
	local IFS="
"

	track_used "$OUTDIR/sw-description"

	[ -n "$DESCRIPTION" ] || error "DESCRIPTION must be set"
	cat <<EOF
software = {
  version = "0.1.0";
  description = "$DESCRIPTION";
EOF

	# handle boards files first
	for file in "$OUTDIR/sw-description-"*-*; do
		[ -e "$file" ] || break
		track_used "$file"
		board="${file#*sw-description-*-}"
		[ -e "$OUTDIR/sw-description-done-$board" ] && continue
		touch "$OUTDIR/sw-description-done-$board"
		board_normalize=$(printf %s "$board" | tr -c '[:alnum:]' '_')
		board_hwcompat=$(eval "printf %s \"\$HW_COMPAT_$board_normalize"\")
		[ -n "$board_hwcompat" ] || board_hwcompat="$HW_COMPAT"
		[ -n "$board_hwcompat" ] || error "HW_COMPAT or HW_COMPAT_%s must be set" "$board_normalize"
		indent=2 write_line "$board = {"
		indent=4 write_line "hardware-compatibility = [ \"$board_hwcompat\" ];"
		for file in "$OUTDIR/sw-description-"*"-$board"; do
			[ -s "$file" ] || continue
			section=${file##*sw-description-}
			section=${section%%-*}
			indent=4 write_line "$section: ("
			indent=6 reindent "$file"
			# also need to include common files if any
			[ -e "$OUTDIR/sw-description-$section" ] \
				&& indent=6 reindent "$OUTDIR/sw-description-$section"
			indent=4 write_line ");"
		done
		indent=2 write_line "};"
	done

	# only set global hardware-compatibility if no board specific ones found
	if [ -z "$board" ]; then
		[ -n "$HW_COMPAT" ] || error "HW_COMPAT must be set"
		echo "  hardware-compatibility = [ \"$HW_COMPAT\" ];"
	fi

	for file in "$OUTDIR/sw-description-"*; do
		board="${file##*sw-description-}"
		section="${board%-*}"
		[ "$section" = "$board" ] && board="" || board="${board#*-}"
	done

	# main sections for all boards
	for section in images files scripts; do
		file="$OUTDIR/sw-description-$section"
		[ -e "$file" ] || continue
		track_used "$file"
		indent=2 write_line "" "$section: ("
		indent=4 reindent "$OUTDIR/sw-description-$section"
		indent=2 write_line ");"
	done

	# Store highest versions in special comments
	if [ -e "$OUTDIR/sw-description-versions" ]; then
		track_used "$OUTDIR/sw-description-versions"
		sort -u -k 1,1 -k 4,4 -k 1 < "$OUTDIR/sw-description-versions" \
				| sort -u -k 1,1 -k 4,4 -c \
			|| error "above component used multiple times with different versions or install-if mode"
		sort -u -k 1,1 -k 4,4 -k 1 < "$OUTDIR/sw-description-versions" \
				| sed -e 's/^/  #VERSION /'
	elif [ -z "$FORCE_VERSION" ]; then
		error "No versions found: empty image?\nSet FORCE_VERSION=1 to allow building"
	fi
	[ -n "$FORCE_VERSION" ] && echo "  #FORCE_VERSION"
	[ -n "$CONTAINER_CLEAR" ] && echo "  #CONTAINER_CLEAR"
	case "$POST_ACTION" in
	poweroff) echo " #POSTACT_POWEROFF";;
	wait) echo " #POSTACT_WAIT";;
	container) echo " #POSTACT_CONTAINER";;
	""|reboot) ;;
	*) error "invalid POST_ACTION \"%s\", must be empty, poweroff or wait" "$POST_ACTION";;
	esac

	# and also add extra debug comments
	for line in $DEBUG_SWDESC; do
		indent=2 write_line "$line"
	done


	indent=0 write_line "};"
}

check_common_mistakes() {
	local swdesc="$OUTDIR/$1"

	# grep for common patterns of easy mistakes that would fail installing
	! grep -qF '$6$salt$hash' "$swdesc" \
		|| error "Please set user passwords (usermod command in .desc)"
}

sign() {
	local file="$OUTDIR/$1"

	track_used "$file.sig"

	[ -e "$file.sig" ] && [ "$file.sig" -nt "$file" ] && return
	[ -n "$PRIVKEY" ] || error "PRIVKEY must be set"
	[ -n "$PUBKEY" ] || error "PUBKEY must be set"
	[ -r "$PRIVKEY" ] || error "Cannot read PRIVKEY: %s" "$PRIVKEY"
	[ -r "$PUBKEY" ] || error "Cannot read PUBKEY: %s" "$PUBKEY"

	openssl cms -sign -in "$file" -out "$file.sig.tmp" \
		-signer "$PUBKEY" -inkey "$PRIVKEY" \
		-outform DER -nosmimecap -binary \
		${PRIVKEY_PASS:+-passin $PRIVKEY_PASS} \
		|| error "Could not sign %s" "$file"

	# Note if anyone needs debugging, can be verified with:
	# openssl cms -verify -inform DER -in "$file.sig" -content "$file" \
	#     -nosmimecap -binary -CAfile "$PUBKEY" > /dev/null

	mv "$file.sig.tmp" "$file.sig"
}

make_cpio() {
	check_common_mistakes sw-description
	sign sw-description
	(
		cd "$OUTDIR" || error "Could not enter %s" "$OUTDIR"
		printf %s "$FILES" | cpio -o -H crc -L --quiet
	) > "$OUT"

	CPIO_FILES=$(cpio -t --quiet < "$OUT")
	[ "$CPIO_FILES" = "$FILES" ] \
		|| error "cpio does not contain files we requested (in the order we requested): check %s" "$OUT"
}

track_used() {
	local file

	for file; do
		# only track files inside outdir
		[ "${file#$OUTDIR}" = "$file" ] && continue

		printf "%s\n" "$file" >> "$OUTDIR/used_files"
	done
}

cleanup_outdir() {
	local file

	sort < "$OUTDIR/used_files" > "$OUTDIR/used_files.sorted"
	find "$OUTDIR" | sort \
		| join -v 1 - "$OUTDIR/used_files.sorted" \
		| xargs rm -f
}

update_mkswu_conf() {
	local confbase="${CONFIG##*/}"
	local NEW_CONFIG="$CONFIG"
	
	if [ "$confbase" = mkimage.conf ]; then
		NEW_CONFIG="$(dirname "$CONFIG")/mkswu.conf"
		[ -e "$NEW_CONFIG" ] && error "Trying to convert from mkimage.conf to mkswu.conf, but mkswu.conf already exists!"
	fi

	[ -e "$CONFIG_DIR" ] || mkdir -vp "$CONFIG_DIR"

	# subshell to not source multiple versions of same file
	(
		set +e
		sha=$(sha256sum "$SCRIPT_DIR/mkswu.conf.defaults")
		sha=${sha%% *}
		if [ -e "$CONFIG" ]; then
			DEFAULTS_MKSWU_CONF_SHA256=$(sed -ne 's/DEFAULTS_\(MKIMAGE\|MKSWU\)_CONF_SHA256="\(.*\)"/\2/p' "$CONFIG")
			# config exist + no sha: don't update
			[ -z "$DEFAULTS_MKSWU_CONF_SHA256" ] && exit
			# sha didn't change: don't update
			[ "$DEFAULTS_MKSWU_CONF_SHA256" = "$sha" ] && exit

			# keep old version
			cp "$CONFIG" "$CONFIG.autosave-$(date +%Y%m%d)" \
				|| error "Could not update config %s" "$CONFIG"
			

			# update hash, trim comments/empty lines past auto section comment
			# and update obsolete header if still present
			sed -e "s/^DEFAULTS_\(MKSWU\|MKIMAGE\)_CONF_SHA256=.*/DEFAULTS_MKSWU_CONF_SHA256=\"$sha\"/" \
			    -e '/^## auto section/p' -e '/^## auto section/,$ {/^#\|^$/ d}' \
			    -e 's/^# defaults section: if you remove this include you must keep this file up/# defaults section: used to keep auto section comments below up to date/' \
			    -e 's/^# to date with mkimage.conf\(.defaults\)\? changes!/# if you remove it the file will not be edited again./' \
			    -e '/^\. .*mkimage.conf.defaults/d' \
			    "$CONFIG" > "$NEW_CONFIG.new" \
			    || error "Could not update config %s" "$CONFIG"
		else
			cat > "$NEW_CONFIG.new" <<EOF \
				|| error "Could not update config %s" "$CONFIG"
# defaults section: used to keep auto section comments below up to date
# if you remove it the file will not be edited again.
DEFAULTS_MKSWU_CONF_SHA256="$sha"

## user section: this won't be touched

## auto section: you can make changes here but comments will be lost
EOF
		fi
		sed -e 's/^[^#$]/#&/' "$SCRIPT_DIR/mkswu.conf.defaults" >> "$NEW_CONFIG.new" \
			&& mv "$NEW_CONFIG.new" "$NEW_CONFIG" \
			|| error "Could not update config %s" "$CONFIG"

		info "Updated config file %s" "$NEW_CONFIG"
	) || exit

	# if renamed, remove old config after all is done
	if [ "$CONFIG" != "$NEW_CONFIG" ] && [ -e "$NEW_CONFIG" ]; then
		rm -f "$CONFIG"
		CONFIG="$NEW_CONFIG"
	fi
}

mkswu_import() {
	# import standalone config file and its keys to $HOME/swu
	local NEW_CONFIG_DIR="$CONFIG_DIR"
	[ "${CONFIG#$CONFIG_DIR}" = "$CONFIG" ] \
		|| NEW_CONFIG_DIR="$HOME/mkswu"
	local NEW_CONFIG="$NEW_CONFIG_DIR/mkswu.conf"
	[ -e "$CONFIG" ] || error "%s does not exist\nUse --config to specify what to import" "$CONFIG"
	CONFIG_DIR="$(realpath "$(dirname "$CONFIG")")" \
		|| error "Could not resolve %s directory name" "$CONFIG"

	if [ -e "$NEW_CONFIG" ]; then
		info "Config %s already exists, skipping import" "$NEW_CONFIG"
		return
	fi

	info "Importing config %s and associated keys to %s" "$CONFIG" "$NEW_CONFIG_DIR"

	mkdir -vp "$NEW_CONFIG_DIR"
	for file in "$PRIVKEY" "$PUBKEY" "$ENCRYPT_KEYFILE"; do
		[ -z "$file" ] && continue
		# try to second-guess key position: if key file is in
		# new config dir we probably meant to use old one
		[ "${file#$NEW_CONFIG_DIR}" != "$file" ] \
			&& file="$CONFIG_DIR/${file#$NEW_CONFIG_DIR}"
		[ -e "$file" ] \
			|| error "Key file %s could not be found, try setting absolute path in config file and reimport" "${file##*/}"

		cp -v "$file" "$NEW_CONFIG_DIR/" \
			|| error "Could not copy %s to %s" "$file" "$NEW_CONFIG_DIR/"
	done

	sed -e "s@^PRIVKEY=.*@PRIVKEY=\"\$CONFIG_DIR/$(basename "$PRIVKEY")\"@" \
	    -e "s@^PUBKEY=.*@PUBKEY=\"\$CONFIG_DIR/$(basename "$PUBKEY")\"@" \
	    -e "s@^ENCRYPT_KEYFILE=.*@ENCRYPT_KEYFILE=\"\$CONFIG_DIR/$(basename "$ENCRYPT_KEYFILE")\"@" \
	    "$CONFIG" > "$NEW_CONFIG" \
		|| error "Could not update config %s" "$NEW_CONFIG"

	info "Imported config %s to %s" "$CONFIG" "$NEW_CONFIG"
	info "You can know check mkswu works with new config and remove the old directory"
}

absolutize_file_paths() {
	[ "${PRIVKEY#/}" != "$PRIVKEY" ] || PRIVKEY=$(realpath "$PRIVKEY")
	[ "${PUBKEY#/}" != "$PUBKEY" ] || PUBKEY=$(realpath "$PUBKEY")
	[ -z "$ENCRYPT_KEYFILE" ] \
		|| [ "${ENCRYPT_KEYFILE#/}" != "$ENCRYPT_KEYFILE" ] \
		|| ENCRYPT_KEYFILE=$(realpath "$ENCRYPT_KEYFILE")
}

mkswu_genkey_aes() {
	local oldumask

	if [ -z "$ENCRYPT_KEYFILE" ]; then
		info "Info: using default aes key path"
		ENCRYPT_KEYFILE="$CONFIG_DIR/swupdate.aes-key"
		printf "%s\n" '' '# Default encryption key path (set by genkey.sh)' \
			'ENCRYPT_KEYFILE="$CONFIG_DIR/swupdate.aes-key"' >> "$CONFIG" \
			|| error "Could not update default ENCRYPT_KEYFILE in %s" "$CONFIG"
	fi
	if [ -s "$ENCRYPT_KEYFILE" ]; then
		warning "%s already exists, skipping" "$ENCRYPT_KEYFILE"
		return
	fi

	oldumask=$(umask)
	umask 0377
	ENCRYPT_KEY="$(openssl rand -hex 32)" || error "Generating random number failed"
	printf "%s\n" "$ENCRYPT_KEY $(openssl rand -hex 16)" > "$ENCRYPT_KEYFILE"
	umask "$oldumask"

	info "Created encryption keyfile %s" "$ENCRYPT_KEYFILE"
	info "You must also enable aes encryption with examples/initial_setup.desc"
	info "or equivalent"
}

mkswu_genkey_sign() {
	local oldumask
	local CURVE="${GENKEY_CURVE:-secp256k1}"
	local DAYS="${GENKEY_DAYS:-$((5*365))}"

	[ -n "$PRIVKEY" ] || error "PRIVKEY is not set in config file"
	[ -n "$PUBKEY" ] || error "PUBKEY is not set in config file"
	if [ -s "$PRIVKEY" ] && [ -s "$PUBKEY" ]; then
		info "%s already exists, skipping" "$PRIVKEY"
		return
	fi
	[ -n "$GENKEY_CN" ] || error "Certificate common name must be provided with --cn <name>"

	info "Creating signing key %s and its public counterpart %s" "$PRIVKEY" "${PUBKEY##*/}"

	openssl req -x509 -newkey ec -pkeyopt ec_paramgen_curve:"$CURVE" \
		-keyout "$PRIVKEY" -out "$PUBKEY" -subj "/O=SWUpdate/CN=$GENKEY_CN" \
		${GENKEY_PLAIN:+-nodes} ${PRIVKEY_PASS:+-passout $PRIVKEY_PASS} \
		-days "$DAYS" || error "Generating certificate/key pair failed"

	info "%s must be copied over to /etc/swupdate.pem on devices." "$PUBKEY"
	info "The suggested way is using swupdate:"
	info "    %s examples/initial_setup.desc" "$0"
	info "Please set user passwords in initial_setup.desc and generate the image."
	info "If you would like to encrypt your updates, generate your aes key now with:"
	info "    %s --genkey --aes" "$0"
}

mkinit_genkey() {
	local GENKEY_CN
	local KEYPASS KEYPASS_CONFIRM

	[ -e "$PUBKEY" ] && [ -e "$PRIVKEY" ] && return

	while [ -z "$GENKEY_CN" ]; do
		prompt GENKEY_CN "Enter certificate common name:"
	done

	while true; do
		PASS=1 prompt KEYPASS "Enter private key password (4-1024 char)"
		if [ -z "$KEYPASS" ]; then
			info "Empty key password is not recommended, re-enter empty to confirm"
		elif [ "${#KEYPASS}" -lt 4 ] || [ "${#KEYPASS}" -gt 1024 ]; then
			info "Must be between 4 and 1024 characters long"
			continue
		fi
		PASS=1 prompt KEYPASS_CONFIRM "private key password (confirm):"
		echo
		if [ "$KEYPASS" != "$KEYPASS_CONFIRM" ]; then
			info "Passwords do not match"
			continue
		fi
		break
	done

	if [ -n "$KEYPASS" ]; then
		echo "$KEYPASS" | PRIVKEY_PASS="stdin" \
			VERBOSE=1 mkswu_genkey_sign
	else
		GENKEY_PLAIN=1 VERBOSE=1 mkswu_genkey_sign
	fi || exit 1

	# Also prompt for encryption
	local AES

	[ -n "$ENCRYPT_KEYFILE" ] && [ -e "$ENCRYPT_KEYFILE" ] && return

	while true; do
		prompt AES "Use AES encryption? (N/y)"
		case "$AES" in
	        [Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|1) AES=1; break;;
	        [Nn]|[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|0|"") AES=""; break;;
		esac
	done
	if [ -n "$AES" ]; then
		VERBOSE=1 mkswu_genkey_aes
		info "Generated %s" "$ENCRYPT_KEYFILE"
	fi
}

mkinit_geninitdesc() {
	local KEEPATMARKPEM
	local ROOTPW
	local ROOTPW_CONFIRM
	local ATMARKPW
	local ATMARKPW_CONFIRM
	local desc="$CONFIG_DIR/initial_setup.desc"

	[ -e "$desc" ] && return

	while true; do
		prompt KEEPATMARKPEM "Allow updates signed by Atmark Techno? (Y/n)"
		case "$KEEPATMARKPEM" in
	        [Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|1|"")
			KEEPATMARKPEM=1; break;;
	        [Nn]|[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|0)
			KEEPATMARKPEM=""; break;;
		esac
	done
	while true; do
		PASS=1 prompt ROOTPW "root password:"
		if [ -z "$ROOTPW" ]; then
			info "A root password is required"
			continue
		fi
		PASS=1 prompt ROOTPW_CONFIRM "root password (confirm):"
		if [ "$ROOTPW" != "$ROOTPW_CONFIRM" ]; then
			info "Passwords do not match"
			continue
		fi
		ROOTPW=$(echo "$ROOTPW" | sed -e "s/\"/\"'\"'r/")
		ROOTPW=$(printf 'import crypt; print(crypt.crypt(r"%s", crypt.METHOD_SHA512))' "${ROOTPW}" | python3)
		[ -n "$ROOTPW" ] || error "Could not hash password"
		break
	done

	while true; do
		PASS=1 prompt ATMARKPW "atmark user password (empty = same as root):"
		echo
		PASS=1 prompt ATMARKPW_CONFIRM "atmark user password (confirm):"
		echo
		if [ "$ATMARKPW" != "$ATMARKPW_CONFIRM" ]; then
			info "Passwords do not match"
			continue
		fi
		if [ -z "$ATMARKPW" ]; then
			ATMARKPW="$ROOTPW_CONFIRM"
		fi
		ATMARKPW=$(echo "$ROOTPW" | sed -e "s/\"/\"'\"'r/")
		ATMARKPW=$(printf 'import crypt; print(crypt.crypt(r"%s", crypt.METHOD_SHA512))' "$ATMARKPW" | python3)
		[ -n "$ATMARKPW" ] || error "Could not hash password"
		break
	done


	# cleanup if we fail here
	trap "rm -f $desc" EXIT

	cp "$SCRIPT_DIR/examples/initial_setup.desc" "$desc" \
		|| error "Could not copy initial_setup.desc from example dir"
	if [ -z "$KEEPATMARKPEM" ]; then
		sed -i -e 's@>> /etc/swupdate.pem@> /etc/swupdate.pem@' "$desc" \
			|| error "Could not update %s" "$desc"
	fi

	sed -i -e 's:\(^[ \t]*"usermod\).*atmark:\1 -p '\'\""'$ATMARKPW'"\"\'' atmark:' \
			-e 's:\(^[ \t]*"usermod\).*root:\1 -p '\'\""'$ROOTPW'"\"\'' root:' "$desc" \
		|| error "Could not update %s" "$desc"

	trap "" EXIT
}

mkinit_mkimageinitswu() {
	"$0" --config-dir "$CONFIG_DIR" --config "$CONFIG" \
			"$CONFIG_DIR/initial_setup.desc" \
		|| error "Could not generate initial setup swu"
	echo
	info "You can use \"%s\" as is or regenerate an image" "$CONFIG_DIR/initial_setup.swu"
	info "with extra modules with \"%s\" \"%s\" other_desc_files" \
		"$0" "$CONFIG_DIR/initial_setup.swu"
	info
	info "Note that once installed, you must preserve this directory as losing"
	info "key files means you will no longer be able to install new updates without"
	info "manually adjusting /etc/swupdate.pem on devices"
}


mkswu_init() {
	mkinit_genkey
	mkinit_geninitdesc
	mkinit_mkimageinitswu
}

mkimage() {
	local SCRIPT_DIR
	SCRIPT_DIR="$(cd -P -- "$(dirname -- "$0")" && pwd -P)" || error "Could not get script dir"
	local OUT=""
	local OUTDIR=""
	local CONFIG_DIR
	local CONFIG
	local EMBEDDED_SCRIPTS_DIR="$SCRIPT_DIR/scripts"
	local PRE_SCRIPT="swupdate_pre.sh"
	local POST_SCRIPT="$SCRIPT_DIR/swupdate_post.sh"
	local FILES="sw-description
sw-description.sig"
	local FIRST_SWDESC_INIT=1
	local COPY_USB=""
	local MODE=""
	local VERBOSE=2
	local TEXTDOMAINDIR="$SCRIPT_DIR/locale"
	local MKSWU_VERSION=""

	# config file variables
	local PRIVKEY PUBKEY PRIVKEY_PASS
	local ENCRYPT_KEYFILE HW_COMPAT DESCRIPTION

	# genkey options
	local GENKEY_AES="" GENKEY_PLAIN="" GENKEY_CN=""

	# default default values
	local BOOT_SIZE="4M"
	local compress=1
	local main_cwd desc
	local component version board dest

	set -e

	if [ "${SCRIPT_DIR%/usr/bin}" != "$SCRIPT_DIR" ]; then
		SCRIPT_DIR=${SCRIPT_DIR%/bin}/share/mkswu
		TEXTDOMAINDIR="${SCRIPT_DIR%/mkswu}/locale"
		EMBEDDED_SCRIPTS_DIR="$SCRIPT_DIR/scripts"
		POST_SCRIPT="$SCRIPT_DIR/swupdate_post.sh"
	fi

	for CONFIG_DIR in "$SCRIPT_DIR" "$HOME/mkswu"; do
		for CONFIG in mkswu.conf mkimage.conf; do
			if [ -e "$CONFIG_DIR/$CONFIG" ]; then
				CONFIG="$CONFIG_DIR/$CONFIG"
				break 2
			fi
		done
	done
	# not found if doesn't start with /
	# just checking for -e $CONFIG would find ./mkimage.conf...
	[ "${CONFIG#/}" != "$CONFIG" ] \
		|| CONFIG="$CONFIG_DIR/mkswu.conf"

	local ARG SKIP=0
	for ARG; do
		# skip previously used argument
		# using a for loop means we can't shift ahead
		if [ "$SKIP" -gt 0 ]; then
			SKIP=$((SKIP-1))
			continue
		fi
		if [ "$SKIP" -lt 0 ]; then
			set -- "$@" "$ARG"
			continue
		fi

		shift
		# split --switch=value
		if [ "${ARG#--*=}" != "$ARG" ]; then
			set -- "${ARG#--*=}" "$@"
			ARG="${ARG%%=*}"
		fi
		case "$ARG" in
		"-c"|"--config")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			CONFIG="$(realpath -e "$1")" \
				|| error "%s does not exist" "$1"
			SKIP=1
			;;
		"--config-dir")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			CONFIG_DIR="$1"
			CONFIG="$1/mkswu.conf"
			SKIP=1
			;;
		"-o"|"--out")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			OUT="$1"
			[ "${OUT%.swu}" != "$OUT" ] || error "%s must end with .swu" "$OUT"
			SKIP=1
			;;
		"-v"|"--verbose")
			VERBOSE=$((VERBOSE+1))
			;;
		"-q"|"--quiet")
			VERBOSE=$((VERBOSE-1))
			;;
		"--mkconf")
			update_mkswu_conf
			exit 0
			;;
		"--init")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$MODE"
			MODE=init
			;;
		"--import")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$MODE"
			MODE=import
			# for import mode, also use config in current directory if
			# another one wasn't already found/set
			if ! [ -e "$CONFIG" ]; then
				[ -e "mkimage.conf" ] && CONFIG="$PWD/mkimage.conf"
				[ -e "mkswu.conf" ] && CONFIG="$PWD/mkswu.conf"
			fi
			;;
		"--genkey")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$MODE"
			MODE=genkey_sign
			;;
		"--aes")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after --genkey" "$ARG"
			MODE=genkey_aes
			;;
		"--plain")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after --genkey" "$ARG"
			GENKEY_PLAIN=1
			;;
		"--cn")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after --genkey" "$ARG"
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			GENKEY_CN="$1"
			SKIP=1
			;;
		"--version")
			if [ -z "$MKSWU_VERSION" ]; then
				[ -e "$SCRIPT_DIR/.git" ] \
					|| error "mkswu not installed and could not guess mkswu version from git"
				MKSWU_VERSION="$(git --git-dir "$SCRIPT_DIR/.git" describe)"
			fi
			info "mkswu version %s" "$MKSWU_VERSION"
			exit 0
			;;
		"--")
			# stop parsing
			SKIP=-1
			;;
		"-h"|"--help"|"-"*)
			usage
			exit 0
			;;
		*)
			set -- "$@" "$ARG"
			;;
		esac
		[ "$SKIP" -gt 0 ] && shift "$SKIP"
	done

	if [ -e "$SCRIPT_DIR/mkswu.conf.defaults" ]; then
		. "$SCRIPT_DIR/mkswu.conf.defaults"
	fi
	if [ "$MODE" = "import" ] && [ "$CONFIG" = "$HOME/mkswu/mkswu.conf" ]; then
		[ -e "$CONFIG" ] && error "Config already imported (%s). Remove it if you really want to import something else" "$CONFIG"
		error "Could not find config file to import, specify it with --config"
	fi
	if [ -z "$MODE" ] && ! [ -e "$CONFIG" ]; then
		[ -e "mkimage.conf" ] && error "Please import current config with mkswu --import first"
		error "Config file not found, create one with mkswu --init"
	fi
	if [ -n "$CONFIG" ]; then
		trace "Loading config %s" "$CONFIG"
		update_mkswu_conf
		[ -e "$CONFIG" ] || error "%s does not exist" "$CONFIG"
		[ "${CONFIG#/}" = "$CONFIG" ] && CONFIG="./$CONFIG"
		. "$CONFIG"
	fi
	# Force config values from env
	[ -n "$SWMK_PRIVKEY" ] && PRIVKEY="$SWMK_PRIVKEY"
	[ -n "$SWMK_PUBKEY" ] && PUBKEY="$SWMK_PUBKEY"
	[ -n "$SWMK_PRIVKEY_PASS" ] && PRIVKEY_PASS="$SWMK_PRIVKEY_PASS"
	[ -n "$SWMK_ENCRYPT_KEYFILE" ] && ENCRYPT_KEYFILE="$SWMK_ENCRYPT_KEYFILE"
	[ -n "$SWMK_HW_COMPAT" ] && HW_COMPAT="$SWMK_HW_COMPAT"
	[ -n "$SWMK_DESCRIPTION" ] && DESCRIPTION="$SWMK_DESCRIPTION"

	if [ -n "$MODE" ]; then
		[ $# -gt 0 ] && error "--%s had extra arguments?" "$MODE"
		[ -n "$OUT" ] && error "%s is incompatible with --%s" "out" "$MODE"
		"mkswu_$MODE"
		exit 0
	fi

	# actual image building
	if [ -z "$OUT" ]; then
		# OUT defaults to first swu name if not set
		OUT="${1%.desc}.swu"
	fi
	OUTDIR=$(dirname -- "$OUT")/.$(basename -- "$OUT" .swu)
	mkdir -p "$OUTDIR"
	OUTDIR=$(realpath -- "$OUTDIR")
	rm -f "$OUTDIR/sw-description-"* "$OUTDIR/used_files"
	track_used "$OUTDIR"

	main_cwd="$PWD"
	absolutize_file_paths
	# build sw-desc fragments
	for desc; do
		[ -e "$desc" ] || error "%s does not exist" "$desc"
		cd "$(dirname -- "$desc")" || error "cannot enter %s directory" "$desc"
		. "./${desc##*/}"
		# make key files path absolute after each iteration:
		# this is required if a desc file sets a key path
		absolutize_file_paths
		cd "$main_cwd" || error "Cannot return to %s we were in before" "$main_cwd"
	done

	[ -z "$FIRST_SWDESC_INIT" ] || [ -n "$FORCE_VERSION" ] \
		|| error "No or empty desc given?"

	embedded_postinstall_script
	write_sw_desc > "$OUTDIR/sw-description"
	# XXX debian's libconfig is obsolete and does not allow
	# trailing commas at the end of lists (allowed from 1.7.0)
	# probably want to sed these out at some point for compatibility
	# (Note this is only required to run swupdate on debian,
	#  not for image generation)
	make_cpio

	if [ -n "$COPY_USB" ]; then
		info "You have sideloaded containers, copy all these files to USB drive:"
		info "%s" "$(shell_quote "$(realpath "$OUT")") $COPY_USB"
		info
	fi

	cleanup_outdir

	info "Successfully generated %s" "$OUT"
}


# check if sourced: basename $0 should only be mkswu if run directly
[ "$(basename "$0")" != "mkswu" ] && return

mkimage "$@"

#!/bin/sh

# disable noisy shellcheck warnings
# shellcheck disable=SC2039,SC1090,SC2165,SC2167,SC2064,SC2015
# shellcheck disable=SC2247,SC2119,SC1090,SC2120,SC3043,SC3013

if command -v gettext >/dev/null; then
	_gettext() { TEXTDOMAINDIR="$TEXTDOMAINDIR" TEXTDOMAIN=mkswu gettext -- "$@"; }
else
	_gettext() { printf -- "%s" "$@"; }
fi

printmsg() {
	local level="$1"
	shift
	[ "$VERBOSE" -lt "$level" ] && return

	if [ "$#" = "0" ] || [ -z "$1" ]; then
		echo
		return
	fi

	local fmt="$1"
	shift
	# shellcheck disable=SC2059 # fmt is a build time constant
	printf -- "$(_gettext "$fmt")\n" "$@"
}

error() {
	if [ "$#" = "0" ] || [ -z "$1" ]; then
		error "Error called without format string!"
		exit 1
	fi

	local fmt="$1"
	shift
	# shellcheck disable=SC2059 # fmt is a build time constant
	printf -- "ERROR: $(_gettext "$fmt")\n" "$@" >&2
	exit 1
}

warning() {
	printmsg 1 "$@" >&2
}

info() {
	printmsg 2 "$@"
}

trace() {
	printmsg 3 "$@" >&2
}

debug() {
	printmsg 4 "$@" >&2
}

# dash doesn't handle read -s
# and even if it did we wouldn't have gettext wrapping
# so provide our own helper
prompt() {
	local var="$1"
	local prompt_fmt="$2"
	shift 2

	if [ -n "$PASS" ] && tty -s; then
		trap "stty echo" EXIT INT QUIT
		stty -echo
	fi

	# shellcheck disable=SC2059 # fmt is a build time constant
	printf -- "$(_gettext "$prompt_fmt") " "$@"
	read -r "${var?}"

	if [ -n "$PASS" ] && tty -s; then
		stty echo
		trap "" EXIT INT QUIT
		echo
	fi
}

usage() {
	info "Usage: %s [opts] desc [desc...]" "$0"
	info
	info "Options:"
	info "  -c, --config <conf>     path to config (default ~/mkswu/mkswu.conf)"
	info "  -o, --out <out.swu>     path to output file (default from first desc's name)"
	info "  --init                  walk through initial key and first image generation"
	info "  --import                import current directory's config and keys into config dir"
	info "  --genkey                toggle key generation mode (see below for suboptions)"
	info "  --show [--raw] <in.swu> print details about input swu"
	info "  --version               print version and exit"
	info "  desc                    image description file(s), if multiple are given"
	info "                          then the generated image will merge all the contents"
	info
	info "desc file syntax:"
	info "  descriptions are imperative declarations building an image, the following"
	info "  commands available (see README for details):"
	info "  - swdesc_boot <bootfile>"
	info "  - swdesc_tar <tar_file> [--dest <dest>]"
	info "  - swdesc_files [--basedir <basedir>] [--dest <dest>] <files>"
	info "  - swdesc_command '<cmd>'"
	info "  - swdesc_script <script>"
	info "  - swdesc_exec <file> '<cmd>' (file is \$1 in command)"
	info "  - swdesc_embed_container <image_archive>"
	info "  - swdesc_usb_container <image_archive>"
	info "  - swdesc_pull_container <image_url>"
	info
	info "In most cases --version <component> <version> should be set,"
	info "<component> must be extra_os.* in order to update rootfs"
	info
	info "Key generation options:"
	info "  --cn          common name for key (mandatory for signing key)"
	info "  --plain       generate signing key without encryption"
	info "  --aes         generate aes key instead of default rsa key pair"
}

write_line() {
	local line
	for line; do
		[ -z "$line" ] && continue
		printf "%*s%s\n" "$((0${line:+1}?indent:0))" "" "$line"
	done
}

reindent() {
	local padding file
	padding=$(printf "%*s" "${indent:-0}" "")

	for file; do
		[ -e "$file" ] || continue
		sed -e "s/^/$padding/" "$file"
	done
}


link() {
	local src="$1"
	local dest="$2"
	local existing

	track_used "$dest"

	src=$(readlink -e "$src") || error "Cannot find source file: %s" "$1"

	if [ -h "$dest" ]; then
		existing=$(readlink "$dest")
		[ "$src" = "$existing" ] && return
		rm -f "$dest" || error "Could not remove previous link at %s" "$dest"
	elif [ -e "$dest" ]; then
		[ "$(stat -L -c %Y-%s "$src")" = "$(stat -L -c %Y-%s "$dest")" ] && return
		rm -f "$dest" || error "Could not remove previous file at %s" "$dest"
	fi

	# files with hardlinks will mess up the order within the cpio,
	# and thus change the order in which components are installed
	# (e.g. rootfs after post script...)
	# workaround by copying file (reflinks are ok) instead if required
	if [ "$(stat -L -c %h "$src")" != 1 ]; then
		cp --reflink=auto -a "$src" "$dest" || error "Could not copy %s to %s" "$src" "$dest"
	else
		ln -s "$(readlink -e "$src")" "$dest" || error "Could not link %s to %s" "$dest" "$src"
	fi
}

gen_iv() {
	openssl rand -hex 16
}

encrypt_file() {
	local src="$1"
	local dest="$2"
	local iv="$3"

	openssl enc -aes-256-cbc -in "$src" -out "$dest" \
			-K "$ENCRYPT_KEY" -iv "$iv" \
		|| error "failed to encrypt %s" "$src"
}

decrypt_file() {
	local src="$1"
	local dest="${src%.enc}"
	[ "$dest" != "$src" ] || error "File must end in .enc"
	local iv tmp file=${src##*/}
	ivs="${src%/*}/sw-description-ivs"

	[ -e "$ivs" ] || error "ivs file %s does not exist" "$ivs"

	while read -r iv tmp; do
		[ "$tmp" != "$file" ] || break
	done < "$ivs"
	[ "$tmp" = "$file" ] || error "%s not found in %s" "$file" "$ivs"
	setup_encryption
	openssl enc -aes-256-cbc -d -in "$src" -out "$dest" \
			-K "$ENCRYPT_KEY" -iv "$iv" \
		|| error "failed to decrypt %s" "$src"

}

setup_encryption() {
	[ -z "$ENCRYPT_KEYFILE" ] && return
	[ -e "$ENCRYPT_KEYFILE" ] \
		|| error "AES encryption key %s was set but not found.\nPlease create it with genkey.sh --aes" \
			"$ENCRYPT_KEYFILE"
	ENCRYPT_KEY=$(cat "$ENCRYPT_KEYFILE")
	# XXX if sw-description gets encrypted, its iv is here
	ENCRYPT_KEY="${ENCRYPT_KEY% *}"
}

compress() {
	local file_src="$1"
	local file_out="$2"

	track_used "$file_src" "$file_out" "$file_out.validity"

	# check validity with mtime/size
	local stat=$(stat -L -c %Y-%s "$file_src")
	[ "$(cat "$file_out.validity" 2>/dev/null)" = "$stat"  ] \
		&& [ -e "$file_out" ] && return

	ZSTD_CLEVEL="${ZSTD_CLEVEL:-10}" \
	rm -f "$file_out"
	zstd -q -o "$file_out" < "$file_src" \
		|| error "failed to compress %s" "$file_src"
	echo "$stat" > "$file_out.validity"
}

append_file() {
	printf "%s\n" "$FILES_FIRST" "$FILES" \
			| grep -q -x "$file" \
		&& return

	# we want to install anything marked base_os first,
	# because if base_os is written anything like swdesc_command
	# cannot run until baseos has been extracted
	if [ -n "$install_first" ] || [ "$component" = "base_os" ]; then
		FILES_FIRST="$FILES_FIRST
$file"
	else
		FILES="$FILES
$file"
	fi
}

write_entry_stdout() {
	local file_src="$1"
	local file="${file_src##*/}"
	local file_out="$OUTDIR/$file"
	local compress="$compress"
	local install_if="$install_if"
	shift
	local sha256="" iv="" err

	trace "Processing $file"
	[ -e "$file_src" ] || error "Missing source file: %s" "$file_src"

	if [ -n "$compress" ]; then
		# Check if already compressed
		case "$file" in
		*.tar.*)
			if [ "$compress" = force ]; then
				# Force decompression through swupdate.
				# Only gzip and zstd are supported
				case "$file" in
				*.gz) compress=zlib;;
				*.zst) compress=zstd;;
				*) compress="";;
				esac
			else
				# archive handle will handle it
				compress=""
			fi
			;;
		*.apk)
			# already compressed
			compress=""
			;;
		*.zst)
			compress=zstd
			;;
		*)
			# do not compress files < 128 bytes
			if [ "$(stat -c "%s" "$file_src")" -lt 128 ]; then
				compress=""
			else
				compress=zstd
				file="$file.zst"
				file_out="$file_out.zst"
				compress "$file_src" "$file_out"
				file_src="$file_out"
			fi
			;;
		esac
	fi

	if [ -n "$ENCRYPT_KEY" ] && [ -s "$file_src" ]; then
		file="$file.enc"
		file_out="$file_out.enc"
		# if we already had encrypted this file we must reuse the same iv
		if [ -e "$OUTDIR/sw-description-ivs" ]; then
			local tmp
			while read -r iv tmp; do
				[ "$tmp" != "$file" ] || break
			done < "$OUTDIR/sw-description-ivs"
			[ "$tmp" = "$file" ] || iv=""
		fi
		if [ -z "$iv" ]; then
			iv=$(gen_iv)
			# also write it out for scripts
			printf "%s\n" "$iv $file" >> "$OUTDIR/sw-description-ivs"
			track_used "$OUTDIR/sw-description-ivs"
			encrypt_file "$file_src" "$file_out" "$iv"
		fi
		[ -n "$iv" ] || error "Could not generate an iv to encrypt %s" "$file_src"
		file_src="$file_out"

	fi

	append_file "$file"

	[ "$file_src" = "$file_out" ] && track_used "$file_out" \
		|| link "$file_src" "$file_out"

	track_used "$file_out.sha256sum"

	if [ -e "$file_out.sha256sum" ]; then
		sha256=$(cat "$file_out.sha256sum")
		# check validity with mtime + size
		[ "${sha256#* }" = "$(stat -L -c %Y-%s "$file_out")" ] \
			|| sha256=""
		sha256="${sha256% *}"
	fi

	if [ -z "$sha256" ]; then
		sha256=$(sha256sum < "$file_out") \
			|| error "Checksumming %s failed" "$file_out"
		sha256=${sha256%% *}
		printf "%s\n" "$sha256 $(stat -L -c %Y-%s "$file_out")" > "$file_out.sha256sum"
	fi


	write_line "{"
	indent=$((indent+2))
	printf "%s\n" "$show_cmd" | sed -e "s/^/$(printf "%*s" "$indent" "")# /"
	write_line "filename = \"$file\";"
	if [ -n "$version" ]; then
		[ -n "$component" ] || error "version %s was set without associated component" "$version"
		if [ -z "$install_if" ]; then
			case "$component" in
			boot) install_if="different";;
			*) install_if="higher";;
			esac
		fi
		case "$install_if" in
		higher)
			local max
			# handle only x.y.z.t or x.y.z-t
			printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)?(\.[0-9]+)?(\.[0-9]*|-[A-Za-z0-9.]+)?$' \
				|| error "Version %s must be x.y.z.t (numbers < 65536 only) or x.y.z-t (x-z numbers only)" "$version"
			# ... and check for max values
			if [ "${version%-*}" = "${version}" ]; then
				# only dots, "old style version" valid for 16 bits, but now overflow
				# falls back to semver which is signed int but only for 3 elements
				if printf %s "${version}" | grep -qE '\..*\..*\.'; then
					max=65535
				else
					max=2147483647
				fi
				# base_os must be x.y.z-t format to avoid surprises
				# with semver prerelease field filtering
				[ "$component" = "base_os" ] \
					&& error "base_os version %s must be in x[.y[.z]]-t format" "$version"
			else
				# semver, signed int
				max=2147483647
			fi
			err=$(printf %s "$version" | tr '.-' '\n' | awk '
				/^[0-9]+$/ && $1 > '$max' {
					print "1 " $1;
					exit
				}
				/[0-9][a-zA-Z]|[a-zA-Z][0-9]/ {
					print "2 " $1;
					exit
				}')
			case "$err" in
			1\ *) error "version check failed for %s: %s must be <= %s" "$version" "${err#* }" "$max";;
			2\ *) error "version check failed for %s: %s must not mix alpha and digits, e.g.:\n\t1.2.3-rc.4\n\t1.2.3.4\n\t1.2.3-4" \
				"$version" "${err#* }";;
			esac
			;;
		different)
			# different still goes through integer parsing, but is more relaxed
			# as different ordering does not matter, and pure lexicographical
			# is also allowed... Who said painful ?...
			if printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)?(\.[0-9]+)?(\.[0-9]*|-[A-Za-z0-9.-]+)?$'; then
				# same max check as above without mixed alnum check
				local max=2147483647
				[ "${version%-*}" = "${version}" ] \
					&& printf %s "${version}" | grep -qE '\..*\..*\.' \
					&& max=65535
				err=$(printf %s "$version" | tr '.-' '\n' | awk '
					/^[0-9]+$/ && $1 > '$max' {
						print "1 " $1;
						exit
					}')
				case "$err" in
				1\ *) error "version check failed for %s: %s must be <= %s" "$version" "${err#* }" "$max";;
				esac
			else
				# versions with 5+ components, semvers with 4+ leading digits,
				# and the '+' part of semvers are completly ignored and will be
				# considered identical so should be refused.
				# Anything else should be string-compared and is ok.
				printf %s "$version" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]*(\.[0-9]+|-[A-Za-z0-9.-]+)?$' \
					&& error "version %s has too many digit components, please use somthing else" \
						"$version"
				printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)*([+-][A-Za-z0-9.+-]+)?$' \
					&& error "metadata (+ part) in %s while valid semver are ignored by swupdate, please use something else" \
						"$version"
			fi
	 ;;
		*) error "install_if must be higher or different";;
		esac
		[ "${component#* }" = "$component" ] || error "component must not contain spaces (%s)" "$component"
		[ "${version#* }" = "$version" ] || error "version must not contain spaces (%s = %s)" "$component" "$version"
		write_line "name = \"$component\";" \
			   "version = \"$version\";" \
			   "install-if-${install_if} = true;"

		# remember version for scripts
		printf "%s\n" "$component $version $install_if ${board:-*}" >> "$OUTDIR/sw-description-versions"
	elif [ -n "$version" ]; then
		error "version %s was set without associated component" "$version"
	fi
	if [ -n "$main_version" ]; then
		[ -n "$component" ] && [ -n "$version" ] \
			|| error "%s requires --version to be set" "--main-version"
		write_line "# MAIN_COMPONENT $component" \
			   "# MAIN_VERSION $version"
	fi
	[ -n "$compress" ] && write_line "compressed = \"$compress\";"
	[ -n "$iv" ] && write_line "encrypted = true;" "ivt = \"$iv\";"
	write_line "installed-directly = true;"
	write_line "sha256 = \"$sha256\";"
	write_line "$@"

	indent=$((indent-2))
	write_line "},"
}

write_entry() {
	local outfile="$OUTDIR/sw-description-$1${board:+-$board}"
	shift

	# Running init here allows .desc files to override key elements
	# before the first swdesc_* statement
	if [ -n "$FIRST_SWDESC_INIT" ]; then
		FIRST_SWDESC_INIT=""
		setup_encryption
		embedded_preinstall_script
	fi

	write_entry_stdout "$@" >> "$outfile"
}

parse_swdesc() {
	local ARG SKIP=0 NOPARSE=""

	# first argument tells us what to parse for
	local CMD="$1"
	shift

	for ARG; do
		shift
		# skip previously used argument
		# using a for loop means we can't shift ahead
		if [ "$SKIP" -gt 0 ]; then
			SKIP=$((SKIP-1))
			continue
		fi
		case "$NOPARSE$ARG" in
		"-b"|"--board")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			board="$1"
			SKIP=1
			;;
		"-v"|"--version")
			[ $# -lt 2 ] && error "%s requires <component> <version> arguments" "$ARG"
			component="$1"
			version="$2"
			SKIP=2
			;;
		"--extra-os")
			[ "${component#extra_os.}" != "$component" ] || component="extra_os.$component"
			;;
		"--main-version")
			main_version=1
			;;
		"--install-if")
			install_if="$1"
			case "$install_if" in
			higher|different) ;;
			*) error "--install-if must be higher or different";;
			esac
			SKIP=1
			;;
		"--preserve-attributes")
			[ "$CMD" = "tar" ] || [ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files and swdesc_tar" "$ARG"
			preserve_attributes=1
			;;
		"-d"|"--dest")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			[ "$CMD" = "tar" ] || [ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files and swdesc_tar" "$ARG"
			dest="$1"
			SKIP=1
			;;
		"--basedir")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			[ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files" "$ARG"
			basedir="$1"
			SKIP=1
			;;
		--)
			# we can't break loop or we would reorder previously seen
			# arguments with the rest: just tell parsing to not parse anymore
			# setting NOPARSE here will make the case always fall to last element
			NOPARSE=1
			;;
		"-"*)
			error "%s is not a known %s argument" "$ARG" "swdesc_$CMD"
			;;
		*)
			set -- "$@" "$ARG"
			;;
		esac
	done
	case "$CMD" in
	boot)
		[ $# -eq 0 ] && [ -n "$BOOT" ] && return
		[ $# -eq 1 ] || error "swdesc_boot requires an argument\nUsage: swdesc_boot [options] boot_file"
		BOOT="$1"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $BOOT"
		;;
	boot_enc)
		[ $# -eq 0 ] && [ -n "$BOOT" ] && [ -n "$DEK_OFFSETS" ] && return
		[ $# -eq 2 ] || error "swdesc_boot_enc requires two arguments\nUsage: swdesc_boot_enc [options] boot_enc_file dek_offets_file"
		BOOT="$1"
		DEK_OFFSETS="$2"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $BOOT"
		;;
	boot_linux)
		[ $# -eq 0 ] && [ -n "$file" ] && return
		[ $# -eq 1 ] || error "swdesc_boot_linux requires an argument\nUsage: swdesc_boot_linux [options] boot_linux_file"
		file="$1"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $file"
		;;
	tar)
		[ $# -eq 0 ] && [ -n "$source" ] && return
		[ $# -eq 1 ] || error "swdesc_tar requires an argument\nUsage: swdesc_tar [options] file.tar"
		source="$1"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD${dest:+ --dest $dest}${preserve_attributes:+ --preserve-attributes} $source"
		;;
	files)
		[ $# -eq 0 ] && [ -n "$file" ] && [ -n "$tarfiles_src" ] && return
		[ $# -ge 1 ] || error "swdesc_files requires arguments\nUsage: swdesc_files [options] file [files...]"
		tarfiles_src="$(printf "%s\n" "$@")"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD${dest:+ --dest $dest}${preserve_attributes:+ --preserve-attributes} $(printf "%s " "$@")"
		;;
	command*)
		[ $# -eq 0 ] && [ -n "$cmd" ] && return
		[ $# -ge 1 ] || error "swdesc_command requires arguments\nUsage: swdesc_command [options] cmd [cmd..]"
		cmd=""
		for ARG; do
			cmd="${cmd:+$cmd && }$ARG"
		done
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $cmd"
		;;
	script*)
		[ $# -eq 0 ] && [ -n "$script" ] && return
		[ $# -ge 1 ] || error "swdesc_script requires arguments\nUsage: swdesc_script [options] script [args]"
		script="$1"
		shift
		for ARG; do
			cmd="${cmd:+$cmd }$(shell_quote "$ARG")"
		done
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $script $cmd"
		;;
	exec*)
		[ $# -eq 0 ] && [ -n "$cmd" ] && [ -n "$file" ] && return
		[ $# -ge 2 ] || error "swdesc_exec requires at least two arguments\nUsage: swdesc_exec [options] file command"
		file="$1"
		shift
		cmd=""
		for ARG; do
			cmd="${cmd:+$cmd && }$ARG"
		done
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $cmd"
		;;
	*container)
		[ $# -eq 0 ] && [ -n "$image" ] && return
		[ $# -eq 1 ] || error "%s requires an argument\nUsage: %s [options] image" "swdesc_$CMD" "swdesc_$CMD"
		image="$1"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $image"
		;;
	*)
		error "Unhandled command %s" "$CMD"
		;;
	esac
}

pad_boot() {
	local file="${BOOT##*/}"
	local src="$BOOT"
	local size

	BOOT_SIZE=$(numfmt --from=iec "$BOOT_SIZE")
	BOOT="$OUTDIR/$file"

	if [ "$src" -ot "$BOOT" ]; then
		size=$(stat -L -c "%s" "$BOOT")
		if [ "$size" -eq "$BOOT_SIZE" ]; then
			# already up to date
			return
		fi
	fi

	size=$(stat -L -c "%s" "$src") || error "Cannot stat boot file: %s" "$src"
	if [ "$size" -gt "$BOOT_SIZE" ]; then
		error "BOOT_SIZE set smaller than boot file actual size"
	fi
	rm -f "$BOOT"
	cp "$src" "$BOOT"
	truncate -s "$BOOT_SIZE" "$BOOT"
}

swdesc_boot() {
	local BOOT="$BOOT" component=boot version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc boot "$@"

	[ -n "$BOOT_SIZE" ] && pad_boot

	[ "$component" = "boot" ] \
		|| error "Version component for swdesc_boot must be set to boot"
	if [ -z "$version" ]; then
		version=$(strings "$BOOT" \
				| grep -m1 -oE '20[0-9]{2}.[0-1][0-9]-[0-9a-zA-Z.-]*') \
			|| error "Could not guess boot version in %s" "$BOOT"
	fi

	write_entry images "$BOOT" "type = \"raw\";" \
		"device = \"/dev/swupdate_bootdev\";"
}

swdesc_boot_enc() {
	local BOOT="$BOOT" DEK_OFFSETS="$DEK_OFFSETS" offsets
	local component=boot version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc boot_enc "$@"

	[ -n "$BOOT_SIZE" ] && pad_boot

	[ "$component" = "boot" ] \
		|| error "Version component for swdesc_boot must be set to boot"
	[ -n "$version" ] \
		|| error "Version must be set for swdesc_boot_encrypted"

	offsets=$(cat "$DEK_OFFSETS")
	[ -n "$offsets" ] \
		|| error "dek offset file %s was not readable or empty" "$DEK_OFFSETS"

	swdesc_exec_nochroot "$BOOT" \
		'[ -e /dev/swupdate_bootdev ]' \
		"fw_setenv $offsets" \
		'echo 0 > /sys/class/block/$(basename $(readlink /dev/swupdate_bootdev))/force_ro' \
		'dd if=$1 of=/dev/swupdate_bootdev bs=1M conv=fdatasync status=none' \
		'echo 1 > /sys/class/block/$(basename $(readlink /dev/swupdate_bootdev))/force_ro'
}


swdesc_boot_linux() {
	local component=boot_linux version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"
	local file=""

	parse_swdesc boot_linux "$@"

	[ "$component" = "boot_linux" ] \
		|| error "Version component for swdesc_boot_linux must be set to boot_linux"
	[ -n "$version" ] \
		|| error "Version must be set for swdesc_boot_linux"
	[ "$(stat -L -c %s "$file")" -lt "$((26 * 1024 * 1024))" ] \
		|| error "swdesc_boot_linux image must be at most 26MB big"

	swdesc_exec_nochroot "$file" \
		'[ -e /dev/swupdate_bootdev ]' \
		'echo 0 > /sys/class/block/$(basename $(readlink /dev/swupdate_bootdev))/force_ro' \
		'dd if=$1 of=/dev/swupdate_bootdev bs=1M seek=5 conv=fdatasync status=none' \
		'echo 1 > /sys/class/block/$(basename $(readlink /dev/swupdate_bootdev))/force_ro'
}

swdesc_tar() {
	local source="$source" dest="$dest"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"
	local preserve_attributes="$preserve_attributes"
	local target="/target"

	parse_swdesc tar "$@"

	case "$DEBUG_SWDESC" in
	*DEBUG_SKIP_SCRIPTS*) target="";;
	esac
	case "$component" in
	base_os|extra_os*)
		dest="${dest:-/}"
		if [ "${dest#/}" = "$dest" ]; then
			error "OS update must have an absolute dest (was: %s)" "$dest"
		fi
		;;
	*)
		dest="${dest:-/var/app/rollback/volumes}"
		case "$dest" in
		/var/app/rollback/volumes*|/var/app/volumes*)
			# ok
			;;
		/*)
			[ -n "$target" ] \
				&& error "OS is only writable for base/extra_os updates and dest (%s) is not within volumes. Use --extra-os." "$dest"
			;;
		..*|*/../*|*/..)
			error ".. is not allowed in destination path for volume update"
			;;
		*)
			dest="/var/app/rollback/volumes/$dest"
			;;
		esac
	esac

	# it doesn't make sense to not set preserve_attributes
	# for base_os updates: fix it
	if [ "$component" = "base_os" ] \
	    && [ -z "$preserve_attributes" ]; then
		info "Warning: automatically setting --preserve-attributes for base_os update" >&2
		preserve_attributes=1
	fi
	write_entry images "$source" "type = \"archive\";" \
		"path = \"$target$dest\";" \
		"properties: { create-destination = \"true\"; };" \
		"${preserve_attributes:+preserve-attributes = true;}"
}

set_file_from_content() {
	local content="$*"

	file="$(printf %s "$content" | tr -c '[:alnum:]' '_')"
	if [ "${#file}" -gt 40 ]; then
		file="$(printf %s "$file" | head -c 20)..$(printf %s "$file" | tail -c 20)"
	fi
	file="${file}_$(printf %s "$content" | sha1sum | cut -d' ' -f1)"
	file="$OUTDIR/${file}"
}

create_archive() {
	# updates '$file' with new filename
	# basedir, tarfiles_src must be set
	local tarfile_raw tarfile

	set --
	: > "$OUTDIR/tar.validity.tmp"
	for tarfile_raw in $tarfiles_src; do
		if [ -z "$basedir" ]; then
			[ -d "$tarfile_raw" ] \
				&& basedir="$tarfile_raw" \
				|| basedir=$(dirname "$tarfile_raw")
		fi
		tarfile=$(realpath -e -s --relative-to="$basedir" "$tarfile_raw") \
			|| error "%s does not exist" "$tarfile_raw"
		[ "${tarfile#../}" = "$tarfile" ] \
			|| error "%s is not inside %s" "$tarfile_raw" "$basedir"

		find "$tarfile_raw" -exec stat -c "%n-%Y-%s" {} + \
				| sort >> "$OUTDIR/tar.validity.tmp" \
			|| error "Could not create tar for %s" "$tarfile_raw"
		set -- "$@" "$tarfile"
		track_used "$tarfile"
	done

	if [ -z "$file" ]; then
		set_file_from_content "$basedir" "$dest" "$@"
		file="$file.tar"
	elif [ "${file#/}" = "$file" ]; then
		file="$OUTDIR/$file"
	fi

	track_used "$file.validity"
	if ! cmp -s "$file.validity" "$OUTDIR/tar.validity.tmp"; then
		tar -cf "$file" -C "$basedir" "$@" \
			|| error "Could not create tar for %s" "$file"
		mv "$OUTDIR/tar.validity.tmp" "$file.validity"
	else
		rm "$OUTDIR/tar.validity.tmp"
	fi
}

swdesc_files() {
	local file="" dest="$dest" basedir="$basedir"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd
	local preserve_attributes="$preserve_attributes"
	local tarfiles_src="$tarfiles_src"
	local IFS="
"
	parse_swdesc files "$@"

	create_archive

	swdesc_tar "$file"
}


shell_quote() {
	# sh-compliant quote function from http://www.etalabs.net/sh_tricks.html
	printf %s "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/"
}
conf_quote() {
	# Double backslashes, escape double-quotes, replace newlines by \n
	# (the last operation requires reading all input into patternspace first)
	printf %s "$1" | sed  ':a;$!N;$!ba;s/\\/\\\\/g;s/"/\\"/g;s/\n/\\n/g'
}

swdesc_exec_nochroot() {
	local file="$file" cmd="$cmd"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc exec_nochroot "$@"

	# shellcheck disable=SC2016 # $1 in single quotes on purpose
	[ ! -s "$file" ] || [ "$cmd" != "${cmd#*\$1}" ] \
		|| error 'Using swdesc_exec_nochroot with a non-empty file, but not referring to it with $1'

	cmd="sh -c $(shell_quote "$cmd") --"

	write_entry files "$file" "type = \"exec\";" \
		"properties: {" \
		"  cmd: \"$(conf_quote "$cmd")\"" "}"
}

swdesc_exec() {
	local file="$file" cmd="$cmd" chroot_cmd
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc exec "$@"

	# shellcheck disable=SC2016 # $1 in single quotes on purpose
	[ ! -s "$file" ] || [ "$cmd" != "${cmd#*\$1}" ] \
		|| error 'Using swdesc_exec with a non-empty file, but not referring to it with $1'

	case "$component" in
	base_os|extra_os*)
		chroot_cmd="podman run --net=host --rm"
		chroot_cmd="$chroot_cmd -v \${TMPDIR:-/var/tmp}:\${TMPDIR:-/var/tmp}"
		chroot_cmd="$chroot_cmd --rootfs /target sh -c $(shell_quote "$cmd") --"
		;;
	*)
		# If target is read-only we need special handling to run (silly podman tries
		# to write to / otherwise) but keep volumes writable
		chroot_cmd="podman run --net=host --rm --read-only -v /target/var/app/volumes:/var/app/volumes"
		chroot_cmd="$chroot_cmd -v /target/var/app/rollback/volumes:/var/app/rollback/volumes"
		chroot_cmd="$chroot_cmd -v \${TMPDIR:-/var/tmp}:\${TMPDIR:-/var/tmp}"
		chroot_cmd="$chroot_cmd --rootfs /target sh -c $(shell_quote "$cmd") -- "
		;;
	esac

	write_entry files "$file" "type = \"exec\";" \
		"properties: {" \
		"  cmd: \"$(conf_quote "$chroot_cmd")\"" "}"
}

swdesc_command() {
	local orig_cmd="swdesc_command $*"
	local cmd="$cmd" file
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc command "$@"

	set_file_from_content "$cmd"
	[ -e "$file" ] || : > "$file"

	swdesc_exec
}

swdesc_command_nochroot() {
	local orig_cmd="swdesc_command_nochroot $*"
	local cmd="$cmd" file
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc command_nochroot "$@"

	set_file_from_content "$cmd"
	[ -e "$file" ] || : > "$file"

	swdesc_exec_nochroot
}

swdesc_script() {
	local orig_cmd="swdesc_script $*"
	local script="$script"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"
	local cmd="$cmd"

	parse_swdesc script "$@"

	# shellcheck disable=SC2016 # $1 in single quotes on purpose
	swdesc_exec "$script" 'sh $1'" $cmd"
}

swdesc_script_nochroot() {
	local script="$script"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"
	local cmd="$cmd"

	parse_swdesc script_nochroot "$@"

	# shellcheck disable=SC2016 # $1 in single quotes on purpose
	swdesc_exec_nochroot "$script" 'sh $1'" $cmd"
}


swdesc_embed_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc embed_container "$@"

	# shellcheck disable=SC2016 # $TMPDIR and $1 in single quotes on purpose
	swdesc_exec_nochroot "$image" '${TMPDIR:-/var/tmp}/scripts/podman_update --storage /target/var/lib/containers/storage_readonly -l $1'
}

swdesc_pull_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc pull_container "$@"

	# shellcheck disable=SC2016 # $TMPDIR and $1 in single quotes on purpose
	swdesc_command_nochroot '${TMPDIR:-/var/tmp}/scripts/podman_update --storage /target/var/lib/containers/storage_readonly "'"$image"'"'
}

swdesc_usb_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc usb_container "$@"

	local image_usb="${image##*/}"
	if [ "${image_usb%.tar.*}" != "$image_usb" ]; then
		info "Warning: podman does not handle compressed container images without an extra uncompressed copy"
		info "you might want to keep the archive as simple .tar"
	fi
	link "$image" "$OUTDIR/$image_usb"
	sign "$image_usb"
	COPY_USB="${COPY_USB:+$COPY_USB }$(shell_quote "$(realpath "$image")")"
	COPY_USB="$COPY_USB $(shell_quote "$(realpath "$OUTDIR/$image_usb.sig")")"

	# shellcheck disable=SC2016 # $TMPDIR and $1 in single quotes on purpose
	swdesc_command_nochroot '${TMPDIR:-/var/tmp}/scripts/podman_update --storage /target/var/lib/containers/storage_readonly --pubkey /etc/swupdate.pem -l '"/mnt/$image_usb"
}

embedded_preinstall_script() {
	local component="" version="" board="" main_version=""
	local install_if="" show_cmd="pre_script"
	local install_first=1

	local file="scripts.tar" basedir=""
	local tarfiles_src="$EMBEDDED_SCRIPTS_DIR"
	create_archive

	# shellcheck disable=SC2016 # $TMPDIR and $1 in single quotes on purpose
	swdesc_exec_nochroot "$file" 'rm -rf ${TMPDIR:-/var/tmp}/scripts' \
			'mkdir ${TMPDIR:-/var/tmp}/scripts' \
			'cd ${TMPDIR:-/var/tmp}/scripts' \
			'tar x -vf $1' "./$PRE_SCRIPT"
}

embedded_postinstall_script() {
	local component="" version="" board="" main_version=""
	local install_if="" show_cmd="post_script"
	swdesc_script_nochroot "$POST_SCRIPT"
}

swdesc_option() {
	local opt
	for opt; do
		case "$opt" in
		FORCE_VERSION) FORCE_VERSION=1;;
		POST_ACTION=*) POST_ACTION=${opt#POST_ACTION=};;
		NOTIFY_STARTING_CMD=*) NOTIFY_STARTING_CMD="${opt#NOTIFY_STARTING_CMD=}";;
		NOTIFY_FAIL_CMD=*) NOTIFY_FAIL_CMD="${opt#NOTIFY_FAIL_CMD=}";;
		NOTIFY_SUCCESS_CMD=*) NOTIFY_SUCCESS_CMD="${opt#NOTIFY_SUCCESS_CMD=}";;
		ROOTFS_FSTYPE=*) ROOTFS_FSTYPE="${opt#ROOTFS_FSTYPE=}";;
		BOOT_SIZE=*) BOOT_SIZE="${opt#BOOT_SIZE=}";;
		ENCRYPT_KEYFILE=*) ENCRYPT_KEYFILE="${opt#ENCRYPT_KEYFILE=}";;
		PUBKEY=*) PUBKEY="${opt#PUBKEY=}";;
		PRIVKEY=*) PRIVKEY="${opt#PRIVKEY=}";;
		PRIVKEY_PASS=*) PRIVKEY_PASS="${opt#PRIVKEY_PASS=}";;
		DESCRIPTION=*) DESCRIPTION="${opt#DESCRIPTION=}";;
		component=*) component="${opt#component=}";;
		version=*) version="${opt#version=}";;
		install_if=*) install_if="${opt#install_if=}";;
		CONTAINER_CLEAR|NO_PRESERVE_FILES|\
		ENCRYPT_ROOTFS|ENCRYPT_USERFS|\
		SKIP_APP_SUBVOL_SYNC|ALLOW_PUBLIC_CERT|ALLOW_EMPTY_LOGIN)
			SWDESC_OPTS="$SWDESC_OPTS
$opt";;
		*) error "Unknown option for swdesc_option: %s" "$opt";;
		esac
	done
}

write_sw_desc() {
	local indent=4
	local file line section board=""
	local board_hwcompat board_normalize
	local IFS="
"

	track_used "$OUTDIR/sw-description"

	[ -n "$DESCRIPTION" ] || error "DESCRIPTION must be set"
	cat <<EOF
software = {
  # Built with mkswu $MKSWU_VERSION
  version = "0.1.0";
  description = "$DESCRIPTION";
EOF

	# handle boards files first
	for file in "$OUTDIR/sw-description-"*-*; do
		[ -e "$file" ] || break
		board="${file#*sw-description-*-}"
		[ "$board" = "-" ] && continue
		track_used "$file"
		[ -e "$OUTDIR/sw-description-done-$board" ] && continue
		touch "$OUTDIR/sw-description-done-$board"
		board_normalize=$(printf %s "$board" | tr -c '[:alnum:]' '_')
		board_hwcompat=$(eval "printf %s \"\$HW_COMPAT_$board_normalize"\")
		[ -n "$board_hwcompat" ] || board_hwcompat="$HW_COMPAT"
		[ -n "$board_hwcompat" ] || error "HW_COMPAT or HW_COMPAT_%s must be set" "$board_normalize"
		indent=2 write_line "$board = {"
		indent=4 write_line "hardware-compatibility = [ \"$board_hwcompat\" ];"
		for file in "$OUTDIR/sw-description-"*"-$board"; do
			[ -s "$file" ] || continue
			# also include common section if any
			# XXX in case of duplicate here we should favor
			# current board's file and ignore second one instead
			# but it would be better with an explicit "board=none" kind
			# of syntax. The problem would be when to consider these
			# elements versions for sw-versions merging script, as we'd
			# need to check if a board matched first, so leave for later.
			check_duplicate_files "$file" "$OUTDIR/sw-description-$section"
			section=${file##*sw-description-}
			section=${section%%-*}
			indent=4 write_line "$section: ("
			indent=6 reindent "$file" "$OUTDIR/sw-description-$section"
			indent=4 write_line ");"
		done
		indent=2 write_line "};"
	done

	# only set global hardware-compatibility if no board specific ones found
	if [ -z "$board" ]; then
		[ -n "$HW_COMPAT" ] || error "HW_COMPAT must be set"
		echo "  hardware-compatibility = [ \"$HW_COMPAT\" ];"
	fi

	for file in "$OUTDIR/sw-description-"*; do
		board="${file##*sw-description-}"
		section="${board%-*}"
		[ "$section" = "$board" ] && board="" || board="${board#*-}"
	done

	# main sections for all boards
	for section in images files scripts; do
		file="$OUTDIR/sw-description-$section"
		[ -e "$file" ] || continue
		track_used "$file"
		check_duplicate_files "$file"
		indent=2 write_line "" "$section: ("
		indent=4 reindent "$file"
		indent=2 write_line ");"
	done

	# Store highest versions in special comments
	if [ -e "$OUTDIR/sw-description-versions" ]; then
		track_used "$OUTDIR/sw-description-versions"
		sort -u -k 1,1 -k 4,4 -k 1 < "$OUTDIR/sw-description-versions" \
				| sort -u -k 1,1 -k 4,4 -c \
			|| error "above component used multiple times with different versions or install-if mode"
		sort -u -k 1,1 -k 4,4 -k 1 < "$OUTDIR/sw-description-versions" \
				| sed -e 's/^/  #VERSION /'
	elif [ -z "$FORCE_VERSION" ]; then
		error "No versions found: empty image or version not set?"
	fi
	SWDESC_OPTS="$SWDESC_OPTS
${FORCE_VERSION:+FORCE_VERSION}
${CONTAINER_CLEAR:+CONTAINER_CLEAR}
${NO_PRESERVE_FILES:+NO_PRESERVE_FILES}"
	local option
	for option in $SWDESC_OPTS; do
		echo "  # MKSWU_$option 1"
	done
	[ -n "${NOTIFY_STARTING_CMD+1}" ] \
		&& echo "$NOTIFY_STARTING_CMD" | sed -e 's/^/  # MKSWU_NOTIFY_STARTING_CMD /'
	[ -n "${NOTIFY_FAIL_CMD+1}" ] \
		&& echo "$NOTIFY_FAIL_CMD" | sed -e 's/^/  # MKSWU_NOTIFY_FAIL_CMD /'
	[ -n "${NOTIFY_SUCCESS_CMD+1}" ] \
		&& echo "$NOTIFY_SUCCESS_CMD" | sed -e 's/^/  # MKSWU_NOTIFY_SUCCESS_CMD /'
	case "$ROOTFS_FSTYPE" in
	ext4|btrfs) echo "# MKSWU_ROOTFS_FSTYPE $ROOTFS_FSTYPE";;
	"") ;;
	*) error "invalid ROOTFS_FSTYPE \"%s\", must be empty, ext4 or btrfs" "$ROOTFS_FSTYPE";;
	esac
	case "$POST_ACTION" in
	poweroff|wait|container) echo " # MKSWU_POST_ACTION $POST_ACTION";;
	""|reboot) ;;
	*) error "invalid POST_ACTION \"%s\", must be empty, poweroff or wait" "$POST_ACTION";;
	esac

	# and also add extra debug comments
	for line in $DEBUG_SWDESC; do
		indent=2 write_line "$line"
	done


	indent=0 write_line "};"
}

check_common_mistakes() {
	local swdesc="$OUTDIR/$1"

	# shellcheck disable=SC2016 # $ in single quotes... duh
	# grep for common patterns of easy mistakes that would fail installing
	! grep -qF '$6$salt$hash' "$swdesc" \
		|| error "Please set user passwords (usermod command in .desc)"
}

check_duplicate_files() {
	local file duplicates

	duplicates=$(for file; do
		[ -e "$file" ] || continue
		cat "$file"
	done | awk -F\" '
		/filename/ {
			if (seen[$2]) {
				print $2
			}
			seen[$2] = 1;
		}
	')

	[ -z "$duplicates" ] || error "Duplicate files detected in sw-description: duplicate swdesc_* commands?\n%s" "$duplicates"
}

sign() {
	local file="$OUTDIR/$1"

	track_used "$file.sig"

	[ -e "$file.sig" ] && [ "$file.sig" -nt "$file" ] && return
	[ -n "$PRIVKEY" ] || error "PRIVKEY must be set"
	[ -n "$PUBKEY" ] || error "PUBKEY must be set"
	[ -r "$PRIVKEY" ] || error "Cannot read PRIVKEY: %s" "$PRIVKEY"
	[ -r "$PUBKEY" ] || error "Cannot read PUBKEY: %s" "$PUBKEY"

	openssl cms -sign -in "$file" -out "$file.sig.tmp" \
		-signer "$PUBKEY" -inkey "$PRIVKEY" \
		-outform DER -nosmimecap -binary \
		${PRIVKEY_PASS:+-passin "$PRIVKEY_PASS"} \
		|| error "Could not sign %s" "$file"

	mv "$file.sig.tmp" "$file.sig"
}

verify() {
	# note: this is only a helper for debug
	local file="$1"
	openssl cms -verify -inform DER -in "$file.sig" -content "$file" \
		-nosmimecap -binary -CAfile "$PUBKEY" > /dev/null \
		|| error "Signature verification failed for $file"
	echo "$file: OK"
}

mkcpio() {
	FILES="${FILES_FIRST}${FILES}"

	check_common_mistakes sw-description
	sign sw-description
	(
		cd "$OUTDIR" || error "Could not enter %s" "$OUTDIR"
		printf %s "$FILES" | cpio -o -H crc -L --quiet
	) > "$OUT"

	CPIO_FILES=$(cpio -t --quiet < "$OUT")
	[ "$CPIO_FILES" = "$FILES" ] \
		|| error "cpio does not contain files we requested (in the order we requested): check %s" "$OUT"
}

track_used() {
	local file

	for file; do
		# only track files inside outdir
		[ "${file#"$OUTDIR"}" = "$file" ] && continue

		if [ -d "$file" ]; then
			find "$file" -type f
		else
			printf "%s\n" "$file"
		fi >> "$OUTDIR/used_files"
	done
}

cleanup_outdir() {
	local file

	sort < "$OUTDIR/used_files" > "$OUTDIR/used_files.sorted"
	find "$OUTDIR" -not -type d | sort \
		| join -v 1 - "$OUTDIR/used_files.sorted" \
		| xargs -r rm -f

	# also remove any empty dir
	# busybox find does not have find -empty, but we have
	# GNU coreutils so we can use rm --ignore-fail-on-non-empty
	find "$OUTDIR" -depth -mindepth 1 -type d \
		-exec rmdir --ignore-fail-on-non-empty {} +
}

update_mkswu_conf() {
	local confbase="${CONFIG##*/}"
	local NEW_CONFIG="$CONFIG"

	if [ "$confbase" = mkimage.conf ]; then
		NEW_CONFIG="$(dirname "$CONFIG")/mkswu.conf"
		[ -e "$NEW_CONFIG" ] && error "Trying to convert from mkimage.conf to mkswu.conf, but mkswu.conf already exists!"
	fi

	[ -e "$CONFIG_DIR" ] || mkdir -vp "$CONFIG_DIR"

	# subshell to not source multiple versions of same file
	(
		set +e
		sha=$(sha256sum "$SCRIPT_DIR/mkswu.conf.defaults")
		sha=${sha%% *}
		if [ -e "$CONFIG" ]; then
			DEFAULTS_MKSWU_CONF_SHA256=$(sed -ne 's/DEFAULTS_\(MKIMAGE\|MKSWU\)_CONF_SHA256="\(.*\)"/\2/p' "$CONFIG")
			# config exist + no sha: don't update
			[ -z "$DEFAULTS_MKSWU_CONF_SHA256" ] && exit
			# sha didn't change: don't update
			[ "$DEFAULTS_MKSWU_CONF_SHA256" = "$sha" ] && exit

			# keep old version
			cp "$CONFIG" "$CONFIG.autosave-$(date +%Y%m%d)" \
				|| error "Could not update config %s" "$CONFIG"

			# update hash, trim comments/empty lines past auto section comment
			# and update obsolete header if still present
			sed -e "s/^DEFAULTS_\(MKSWU\|MKIMAGE\)_CONF_SHA256=.*/DEFAULTS_MKSWU_CONF_SHA256=\"$sha\"/" \
			    -e '/^## auto section/p' -e '/^## auto section/,$ {/^#\|^$/ d}' \
			    -e 's/^# defaults section: if you remove this include you must keep this file up/# defaults section: used to keep auto section comments below up to date/' \
			    -e 's/^# to date with mkimage.conf\(.defaults\)\? changes!/# if you remove it the file will not be edited again./' \
			    -e '/^\. .*mkimage.conf.defaults/d' \
			    "$CONFIG" > "$NEW_CONFIG.new" \
			    || error "Could not update config %s" "$CONFIG"
		else
			cat > "$NEW_CONFIG.new" <<EOF \
				|| error "Could not update config %s" "$CONFIG"
# defaults section: used to keep auto section comments below up to date
# if you remove it the file will not be edited again.
DEFAULTS_MKSWU_CONF_SHA256="$sha"

## user section: this won't be touched

## auto section: you can make changes here but comments will be lost
EOF
		fi
		sed -e 's/^[^#$]/#&/' "$SCRIPT_DIR/mkswu.conf.defaults" >> "$NEW_CONFIG.new" \
			&& mv "$NEW_CONFIG.new" "$NEW_CONFIG" \
			|| error "Could not update config %s" "$CONFIG"

		info "Updated config file %s" "$NEW_CONFIG" >&2
	) || exit

	# if renamed, remove old config after all is done
	if [ "$CONFIG" != "$NEW_CONFIG" ] && [ -e "$NEW_CONFIG" ]; then
		rm -f "$CONFIG"
		CONFIG="$NEW_CONFIG"
	fi
}

mkswu_import() {
	# import standalone config file and its keys to $HOME/swu
	local NEW_CONFIG_DIR="${MKSWU_IMPORT_CONFIG_DIR:-$HOME/mkswu}"
	local NEW_CONFIG="$NEW_CONFIG_DIR/mkswu.conf"
	CONFIG_DIR="$(realpath "$(dirname "$CONFIG")")" \
		|| error "Could not resolve %s directory name" "$CONFIG"

	[ $# -gt 0 ] && error "--%s had extra arguments?" "$MODE"
	if [ -e "$NEW_CONFIG" ]; then
		warning "Config %s already exists, skipping import" "$NEW_CONFIG"
		return
	fi

	info "Importing config %s and associated keys to %s" "$CONFIG" "$NEW_CONFIG_DIR"

	mkdir -vp "$NEW_CONFIG_DIR"
	for file in "$PRIVKEY" "$PUBKEY" "$ENCRYPT_KEYFILE"; do
		[ -z "$file" ] && continue
		[ -e "$file" ] \
			|| error "Key file %s could not be found, try setting absolute path in config file and reimport" "${file##*/}"

		cp -v "$file" "$NEW_CONFIG_DIR/" \
			|| error "Could not copy %s to %s" "$file" "$NEW_CONFIG_DIR/"
	done

	sed -e "s@^PRIVKEY=.*@PRIVKEY=\"\$CONFIG_DIR/$(basename "$PRIVKEY")\"@" \
	    -e "s@^PUBKEY=.*@PUBKEY=\"\$CONFIG_DIR/$(basename "$PUBKEY")\"@" \
	    -e "s@^ENCRYPT_KEYFILE=.*@ENCRYPT_KEYFILE=\"\$CONFIG_DIR/$(basename "$ENCRYPT_KEYFILE")\"@" \
	    "$CONFIG" > "$NEW_CONFIG" \
		|| error "Could not update config %s" "$NEW_CONFIG"

	info "Imported config %s to %s" "$CONFIG" "$NEW_CONFIG"
	info "You can know check mkswu works with new config and remove the old directory"
}

absolutize_file_paths() {
	[ "${PRIVKEY#/}" != "$PRIVKEY" ] || PRIVKEY=$(realpath "$PRIVKEY")
	[ "${PUBKEY#/}" != "$PUBKEY" ] || PUBKEY=$(realpath "$PUBKEY")
	[ -z "$ENCRYPT_KEYFILE" ] \
		|| [ "${ENCRYPT_KEYFILE#/}" != "$ENCRYPT_KEYFILE" ] \
		|| ENCRYPT_KEYFILE=$(realpath "$ENCRYPT_KEYFILE")
}

mkswu_genkey_aes() {
	local oldumask

	[ $# -gt 0 ] && error "--%s had extra arguments?" "$MODE"
	if [ -z "$ENCRYPT_KEYFILE" ]; then
		info "Info: using default aes key path"
		ENCRYPT_KEYFILE="$CONFIG_DIR/swupdate.aes-key"
		# shellcheck disable=SC2016 # $CONFIG_DIR in single quotes on purpose
		printf "%s\n" '' '# Default encryption key path (set by genkey.sh)' \
			'ENCRYPT_KEYFILE="$CONFIG_DIR/swupdate.aes-key"' >> "$CONFIG" \
			|| error "Could not update default ENCRYPT_KEYFILE in %s" "$CONFIG"
	fi
	if [ -s "$ENCRYPT_KEYFILE" ]; then
		warning "%s already exists, skipping" "$ENCRYPT_KEYFILE"
		return
	fi

	oldumask=$(umask)
	umask 0377
	ENCRYPT_KEY="$(openssl rand -hex 32)" || error "Generating random number failed"
	printf "%s\n" "$ENCRYPT_KEY $(openssl rand -hex 16)" > "$ENCRYPT_KEYFILE"
	umask "$oldumask"

	info "Created encryption keyfile %s" "$ENCRYPT_KEYFILE"
	info "You must also enable aes encryption with examples/initial_setup.desc"
	info "or equivalent"
}

mkswu_genkey_sign() {
	local oldumask
	local CURVE="${GENKEY_CURVE:-secp256k1}"
	local DAYS="${GENKEY_DAYS:-$((5*365))}"

	[ $# -gt 0 ] && error "--%s had extra arguments?" "$MODE"
	[ -n "$PRIVKEY" ] || error "PRIVKEY is not set in config file"
	[ -n "$PUBKEY" ] || error "PUBKEY is not set in config file"
	if [ -s "$PRIVKEY" ] && [ -s "$PUBKEY" ]; then
		warning "%s already exists, skipping" "$PRIVKEY"
		return
	fi
	[ -n "$GENKEY_CN" ] || error "Certificate common name must be provided with --cn <name>"

	info "Creating signing key %s and its public counterpart %s" "$PRIVKEY" "${PUBKEY##*/}"

	openssl req -x509 -newkey ec -pkeyopt ec_paramgen_curve:"$CURVE" \
		-keyout "$PRIVKEY" -out "$PUBKEY" -subj "/O=SWUpdate/CN=$GENKEY_CN" \
		${GENKEY_PLAIN:+-nodes} ${PRIVKEY_PASS:+-passout $PRIVKEY_PASS} \
		-days "$DAYS" || error "Generating certificate/key pair failed"

	info "%s must be copied over to /etc/swupdate.pem on devices." "$PUBKEY"
	info "The suggested way is using swupdate:"
	info "    mkswu initial_setup.desc"
	info "Please set user passwords in initial_setup.desc and generate the image."
	info "If you would like to encrypt your updates, generate your aes key now with:"
	info "    mkswu --genkey --aes"
}

mkswu_internal() {
	[ $# -lt 1 ] && error "%s requires an argument" "--internal"
	local command="$1"
	shift
	case "$command" in
	get_var)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		local var val
		for var; do
			case "$var" in
			*[!0-9a-zA-Z_]*) error "Invalid variable name %s" "$var";;
			esac
			# check if set
			eval 'val=${'"$var"'+1}'
			[ -n "$val" ] || error "Variable %s was not set" "$var"
			eval 'val=$'"$var"
			printf "%s=%s\n" "$var" "$val"
		done
		;;
	sign)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		local file
		for file; do
			[ -e "$file" ] || error "%s does not exist" "$file"
			OUTDIR=$(dirname "$file")
			sign "$(basename "$file")"
		done
		;;

	verify)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		local file
		for file; do
			[ -e "$file" ] || error "%s does not exist" "$file"
			[ -e "$file.sig" ] || error "%s does not exist" "$file.sig"
			verify "$file"
		done
		;;
	decrypt)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		local file
		for file; do
			decrypt_file "$file"
		done
		;;
	mkcpio)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		OUT="$1"
		[ "${OUT%.swu}" != "$OUT" ] || error "%s must end with .swu" "$OUT"
		OUTDIR=$(dirname -- "$OUT")/.$(basename -- "$OUT" .swu)
		shift
		FILES_FIRST=""
		if [ $# -eq 0 ]; then
			[ -e "$OUT" ] || error "%s does not exist" "$OUT"
			FILES="$(cpio -t --quiet < "$OUT")"
			info "Packing:\n%s" "$FILES"
		else
			FILES=$(printf "%s\n" "$@")
		fi
		mkcpio
		info "Successfully generated %s" "$OUT"
		;;
	*)
		error "Unrecognized internal command %s" "$command"
		;;
	esac
}

mkinit_genkey() {
	local GENKEY_CN
	local KEYPASS KEYPASS_CONFIRM

	[ -e "$PUBKEY" ] && [ -e "$PRIVKEY" ] && return

	while [ -z "$GENKEY_CN" ]; do
		prompt GENKEY_CN "Enter certificate common name:"
	done

	while true; do
		PASS=1 prompt KEYPASS "Enter private key password (4-1024 char)"
		if [ -z "$KEYPASS" ]; then
			info "Empty key password is not recommended, re-enter empty to confirm"
		elif [ "${#KEYPASS}" -lt 4 ] || [ "${#KEYPASS}" -gt 1024 ]; then
			info "Must be between 4 and 1024 characters long"
			continue
		fi
		PASS=1 prompt KEYPASS_CONFIRM "private key password (confirm):"
		if [ "$KEYPASS" != "$KEYPASS_CONFIRM" ]; then
			info "Passwords do not match"
			continue
		fi
		break
	done

	if [ -n "$KEYPASS" ]; then
		echo "$KEYPASS" | PRIVKEY_PASS="stdin" \
			VERBOSE=1 mkswu_genkey_sign
	else
		GENKEY_PLAIN=1 VERBOSE=1 mkswu_genkey_sign
	fi || exit 1

	# Also prompt for encryption
	local AES

	[ -n "$ENCRYPT_KEYFILE" ] && [ -e "$ENCRYPT_KEYFILE" ] && return

	while true; do
		prompt AES "Use AES encryption? (N/y)"
		case "$AES" in
		[Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|1) AES=1; break;;
		[Nn]|[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|0|"") AES=""; break;;
		esac
	done
	if [ -n "$AES" ]; then
		VERBOSE=1 mkswu_genkey_aes
		info "Generated %s" "$ENCRYPT_KEYFILE"
	fi
}

geninitdesc_hashpw() {
	local plain="$1"

	if command -v python3 >/dev/null; then
		printf 'import crypt; print(crypt.crypt(r"%s", crypt.METHOD_SHA512))' "$plain" | python3
	elif command -v mkpasswd >/dev/null; then
		printf "%s" "$plain" | mkpasswd
	else
		error "No command to hash password"
	fi
}

geninitdesc_promptpass() {
	local user="$1"
	local password
	local confirm

	while true; do
		if [ "$user" = "root" ]; then
			PASS=1 prompt password "%s user password:" "$user"
			if [ -z "$password" ]; then
				info "A root password is required"
				continue
			fi
		else
			PASS=1 prompt password "%s user password (empty = locks account):" "$user"
		fi
		PASS=1 prompt confirm  "%s user password (confirm):" "$user"
		if [ "$password" != "$confirm" ]; then
			info "Passwords do not match"
			continue
		fi
		if [ -z "$password" ]; then
			password="-L"
		else
			password=$(echo "$password" | sed -e "s/\"/\"'\"'r/")
			password=$(geninitdesc_hashpw "$password")
			[ -n "$password" ] || error "Could not generate password"
			password="-p '\"'$password'\"'"
		fi
		break
	done
	PASSWD="$password"
}

geninitdesc_prompt_autoupdate() {
	while true; do
		prompt AUTOUPDATE "Enable auto-update of BaseOS image from armadillo.atmark-techno.com servers? (y/N)"
		case "$AUTOUPDATE" in
		[Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|1)
			break;;
		[Nn]|[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|0|"")
			AUTOUPDATE=""; return;;
		esac
	done

	while true; do
		prompt AUTOUPDATE "Select update frequency ([weekly]/daily)"
		case "$AUTOUPDATE" in
		weekly|"")
			AUTOUPDATE="next week"; break;;
		daily)
			AUTOUPDATE="tomorrow"; break;;
		esac
	done
}

geninitdesc_fixinitdesc() {
	local version
	version=$(sed -ne 's/.*version=\([0-9]*\).*/\1/p' "$desc")
	if [ -z "$version" ]; then
		echo "initial_setup.desc is too old, regenerating it"
		echo "old initial_setup.desc is kept in %s" "$desc.old"
		mv "$desc" "$desc.old" || error "Could not rename %s" "$desc"
		return 1
	fi

	if [ "$version" -le 1 ]; then
		info "atmark password was incorrectly generated, regenerating it"
		info "if initial_setup was already installed please adjust password"
		info "with %s if necessary" "$SCRIPT_DIR/examples/reset_atmark_pass.desc"
		
		local PASSWD
		geninitdesc_promptpass atmark

		sed -i -e 's:\(^[ \t]*"usermod\).*atmark:\1 '"$PASSWD"' atmark:' \
				-e 's/version=[0-9]*/version=2/' \
				"$desc" \
			|| error "Could not update %s" "$desc"
	fi
}

mkinit_geninitdesc() {
	local KEEPATMARKPEM
	local AUTOUPDATE=""
	local PASSWD
	local ROOTPW
	local ATMARKPW
	local desc="$CONFIG_DIR/initial_setup.desc"

	[ -e "$desc" ] && geninitdesc_fixinitdesc && return

	while true; do
		prompt KEEPATMARKPEM "Allow updates signed by Atmark Techno? (Y/n)"
		case "$KEEPATMARKPEM" in
		[Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|1|"")
			KEEPATMARKPEM=1; break;;
		[Nn]|[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|0)
			KEEPATMARKPEM=""; break;;
		esac
	done

	geninitdesc_promptpass "root"
	ROOTPW="$PASSWD"
	geninitdesc_promptpass "atmark"
	ATMARKPW="$PASSWD"

	if [ -n "$KEEPATMARKPEM" ]; then
		geninitdesc_prompt_autoupdate
	fi


	# cleanup if we fail here
	trap "rm -f $desc.tmp" EXIT

	cp "$SCRIPT_DIR/examples/initial_setup.desc" "$desc.tmp" \
		|| error "Could not copy initial_setup.desc from example dir"
	if [ -z "$KEEPATMARKPEM" ]; then
		sed -i -e 's@>> /etc/swupdate.pem@> /etc/swupdate.pem@' "$desc.tmp" \
			|| error "Could not update %s" "$desc.tmp"
	fi

	sed -i -e 's:\(^[ \t]*"usermod\).*atmark:\1 '"$ATMARKPW"' atmark:' \
			-e 's:\(^[ \t]*"usermod\).*root:\1 '"$ROOTPW"' root:' "$desc.tmp" \
		|| error "Could not update %s" "$desc.tmp"

	if [ -n "$AUTOUPDATE" ]; then
		cat >> "$desc.tmp" <<EOF \
			|| error "Could not update %s" "$desc.tmp"

# autoupdate
swdesc_command 'rc-update add swupdate-url default' \
        'echo https://download.atmark-techno.com/armadillo-iot-g4/image/baseos-x2-latest.swu > /etc/swupdate.watch' \
        'echo -e "schedule=\"0 $AUTOUPDATE\"\nrdelay=21600" > /etc/conf.d/swupdate-url'
EOF
	fi

	mv "$desc.tmp" "$desc" \
		|| error "Could not rename %s" "$desc"
	trap "" EXIT
}

mkinit_mkimageinitswu() {
	"$0" --config-dir "$CONFIG_DIR" --config "$CONFIG" \
			"$CONFIG_DIR/initial_setup.desc" \
		|| error "Could not generate initial setup swu"
	echo
	info "You can use \"%s\" as is or regenerate an image" "$CONFIG_DIR/initial_setup.swu"
	info "with extra modules with: mkswu \"%s\" other_desc_files" \
		"$CONFIG_DIR/initial_setup.desc"
	info
	info "Note that once installed, you must preserve this directory as losing"
	info "key files means you will no longer be able to install new updates without"
	info "manually adjusting /etc/swupdate.pem on devices"
}


mkswu_init() {
	mkinit_genkey
	mkinit_geninitdesc
	mkinit_mkimageinitswu
}

mkswu_show() {
	local swu desc
	for swu; do
		[ "$swu" != "${swu%.swu}" ] \
			|| error "File does not end in .swu: %s" "$swu"

		printf "%s\n\n" "$swu"

		desc=$(cpio -i --quiet --to-stdout sw-description < "$swu")
		[ -n "$desc" ] || error "Could not get swu sw-description content from %s" "$swu"

		# default to raw for old swu generated before command hints
		if ! printf "%s\n" "$desc" | grep -q '# swdesc'; then
			info "SWU was build with an old version of mkswu or was empty,"
			info "falling back to --raw"
			echo
			SHOW_RAW=1
		fi
		if [ -n "$SHOW_RAW" ]; then
			printf "%s\n" "$desc"
			continue
		fi

		printf "%s\n" "$desc" | awk '
			/^ *# Built with mkswu/ {
				print "# built with mkswu", $NF
			}
			/^ *# swdesc_/ {
				gsub(/ *# /, "")
				cmd=$0
				if (seen[cmd]) {
					cmd=""
				} else {
					seen[cmd]=1
				}
			}
			/^ *version =/ && cmd {
				gsub(/.*= "|";/, "")
				version[cmd]=$0
			}
			/^ *name =/ && cmd {
				gsub(/.*= "|";/, "")
				component[cmd]=$0
			}
			/^ *encrypted = true/ && cmd {
				encrypted[cmd]="1"
			}
			/^ *install-if-different/ {
				install_if[cmd]="different"
			}
			/^ *}/ && cmd {
				cmd=""
			}
			/^ *# MKSWU_/ {
				gsub(/ *# MKSWU_/, "swdesc_option ")
				gsub(/ 1$/, "")
				print
			}
			END {
				for (cmd in seen) {
				print ""
				print cmd
				if (component[cmd] && version[cmd]) {
					print "  --version", component[cmd], version[cmd]
					if (install_if[cmd]) {
						print "  --install-if", install_if[cmd]
					}
				}
				if (encrypted[cmd]) {
					print "  (encrypted)"
				}
			}
			}
			'
	done
}

mkimage() {
	local SCRIPT_DIR
	SCRIPT_DIR="$(cd -P -- "$(dirname -- "$0")" && pwd -P)" || error "Could not get script dir"
	local OUT=""
	local OUTDIR=""
	local CONFIG_DIR
	local CONFIG
	local EMBEDDED_SCRIPTS_DIR="$SCRIPT_DIR/scripts"
	local PRE_SCRIPT="swupdate_pre.sh"
	local POST_SCRIPT="$SCRIPT_DIR/swupdate_post.sh"
	local FILES_FIRST="sw-description
sw-description.sig"
	local FILES=""
	local FIRST_SWDESC_INIT=1
	local COPY_USB=""
	local MODE=""
	local VERBOSE=2
	local TEXTDOMAINDIR="$SCRIPT_DIR/locale"
	local MKSWU_VERSION=""

	# config file variables
	local PRIVKEY PUBKEY PRIVKEY_PASS
	local ENCRYPT_KEYFILE HW_COMPAT DESCRIPTION

	# mode options
	local GENKEY_PLAIN="" GENKEY_CN=""
	local SHOW_RAW=""

	# default default values
	local BOOT_SIZE="4M"
	local compress=1
	local main_cwd desc
	local component version board="" dest=""
	local install_first="" main_version="" show_cmd=""

	set -e

	if [ "${SCRIPT_DIR%/usr/bin}" != "$SCRIPT_DIR" ]; then
		SCRIPT_DIR=${SCRIPT_DIR%/bin}/share/mkswu
		TEXTDOMAINDIR="${SCRIPT_DIR%/mkswu}/locale"
		EMBEDDED_SCRIPTS_DIR="$SCRIPT_DIR/scripts"
		POST_SCRIPT="$SCRIPT_DIR/swupdate_post.sh"
	fi

	for CONFIG_DIR in "$SCRIPT_DIR" "$HOME/mkswu"; do
		for CONFIG in mkswu.conf mkimage.conf; do
			if [ -e "$CONFIG_DIR/$CONFIG" ]; then
				CONFIG="$CONFIG_DIR/$CONFIG"
				break 2
			fi
		done
	done
	# not found if doesn't start with /
	# just checking for -e $CONFIG would find ./mkimage.conf...
	[ "${CONFIG#/}" != "$CONFIG" ] \
		|| CONFIG="$CONFIG_DIR/mkswu.conf"

	if [ -z "$MKSWU_VERSION" ]; then
		if [ -e "$SCRIPT_DIR/.git" ]; then
			MKSWU_VERSION="$(git --git-dir "$SCRIPT_DIR/.git" describe)"
		elif [ -e "$SCRIPT_DIR/.version" ]; then
			MKSWU_VERSION=$(cat "$SCRIPT_DIR/.version")
		else
			error "mkswu not installed and could not guess mkswu version from git"
		fi
	fi

	local ARG SKIP=0
	for ARG; do
		# skip previously used argument
		# using a for loop means we can't shift ahead
		if [ "$SKIP" -gt 0 ]; then
			SKIP=$((SKIP-1))
			continue
		fi
		if [ "$SKIP" -lt 0 ]; then
			set -- "$@" "$ARG"
			continue
		fi

		shift
		# split --switch=value
		if [ "${ARG#--*=}" != "$ARG" ]; then
			set -- "${ARG#--*=}" "$@"
			ARG="${ARG%%=*}"
		fi
		case "$ARG" in
		"-c"|"--config")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			CONFIG="$(realpath -e "$1")" \
				|| error "%s does not exist" "$1"
			CONFIG_DIR="${CONFIG%/*}"
			[ -n "$CONFIG_DIR" ] || CONFIG_DIR=/
			SKIP=1
			;;
		"--config-dir")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			CONFIG_DIR="$1"
			CONFIG="$1/mkswu.conf"
			SKIP=1
			;;
		"-o"|"--out")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			OUT="$1"
			[ "${OUT%.swu}" != "$OUT" ] || error "%s must end with .swu" "$OUT"
			SKIP=1
			;;
		"-vv"*)
			ARG=${ARG#-}
			while [ "${ARG#v}" != "$ARG" ]; do
				ARG="${ARG#v}"
				VERBOSE=$((VERBOSE+1))
			done
			[ -z "$ARG" ] || error "Only v can be repeated in -vvv..."
			;;
		"-v"|"--verbose")
			VERBOSE=$((VERBOSE+1))
			;;
		"-qq"*)
			ARG=${ARG#-}
			while [ "${ARG#q}" != "$ARG" ]; do
				ARG="${ARG#q}"
				VERBOSE=$((VERBOSE-1))
			done
			[ -z "$ARG" ] || error "Only q can be repeated in -qqq..."
			;;
		"-q"|"--quiet")
			VERBOSE=$((VERBOSE-1))
			;;
		"--mkconf")
			update_mkswu_conf
			exit 0
			;;
		"--init")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$MODE"
			MODE=init
			;;
		"--import")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$MODE"
			MODE=import
			# for import mode, also use config in current directory if
			# another one wasn't already found/set
			if ! [ -e "$CONFIG" ]; then
				[ -e "mkimage.conf" ] && CONFIG="$PWD/mkimage.conf"
				[ -e "mkswu.conf" ] && CONFIG="$PWD/mkswu.conf"
				CONFIG_DIR="$PWD"
			fi
			;;
		"--internal")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$MODE"
			MODE=internal
			;;
		"--show")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$MODE"
			MODE=show
			;;
		"--raw")
			[ "$MODE" = "show" ] || error "%s must be passed after %s" "$ARG" "--show"
			SHOW_RAW=1
			;;
		"--genkey")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$MODE"
			MODE=genkey_sign
			;;
		"--aes")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after %s" "$ARG" "--genkey"
			MODE=genkey_aes
			;;
		"--plain")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after %s" "$ARG" "--genkey"
			GENKEY_PLAIN=1
			;;
		"--cn")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after %s" "$ARG" "--genkey"
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			GENKEY_CN="$1"
			SKIP=1
			;;
		"--version")
			info "mkswu version %s" "$MKSWU_VERSION"
			exit 0
			;;
		"--")
			# stop parsing
			SKIP=-1
			;;
		"-h"|"--help")
			usage
			exit 0
			;;
		"-"*)
			error "Unrecognized option %s" "$ARG"
			;;
		*)
			set -- "$@" "$ARG"
			;;
		esac
		[ "$SKIP" -gt 0 ] && shift "$SKIP"
	done

	. "$SCRIPT_DIR/mkswu.conf.defaults"
	if [ "$MODE" = "import" ] && ! [ -e "$CONFIG" ]; then
		error "Could not find config file to import, specify it with --config"
	fi
	if [ -z "$MODE" ] && ! [ -e "$CONFIG" ]; then
		[ -e "mkimage.conf" ] && error "Please import current config with mkswu --import first"
		error "Config file not found, create one with mkswu --init"
	fi
	if [ -n "$CONFIG" ]; then
		trace "Loading config %s" "$CONFIG"
		update_mkswu_conf
		[ -e "$CONFIG" ] || error "%s does not exist" "$CONFIG"
		[ "${CONFIG#/}" = "$CONFIG" ] && CONFIG="./$CONFIG"
		. "$CONFIG"
	fi
	# Force config values from env
	[ -n "${MKSWU_PRIVKEY+1}" ] && PRIVKEY="$MKSWU_PRIVKEY"
	[ -n "${MKSWU_PUBKEY+1}" ] && PUBKEY="$MKSWU_PUBKEY"
	[ -n "${MKSWU_PRIVKEY_PASS+1}" ] && PRIVKEY_PASS="$MKSWU_PRIVKEY_PASS"
	[ -n "${MKSWU_ENCRYPT_KEYFILE+1}" ] && ENCRYPT_KEYFILE="$MKSWU_ENCRYPT_KEYFILE"
	[ -n "${MKSWU_HW_COMPAT+1}" ] && HW_COMPAT="$MKSWU_HW_COMPAT"
	[ -n "${MKSWU_DESCRIPTION+1}" ] && DESCRIPTION="$MKSWU_DESCRIPTION"

	if [ -n "$MODE" ]; then
		[ -n "$OUT" ] && error "%s is incompatible with --%s" "out" "$MODE"
		"mkswu_$MODE" "$@"
		exit 0
	fi

	# actual image building
	if [ -z "$OUT" ]; then
		# OUT defaults to first swu name if not set
		OUT="${1%.desc}.swu"
	fi
	OUTDIR=$(dirname -- "$OUT")/.$(basename -- "$OUT" .swu)
	mkdir -p "$OUTDIR"
	OUTDIR=$(realpath -- "$OUTDIR")
	rm -f "$OUTDIR/sw-description-"* "$OUTDIR/used_files"

	main_cwd="$PWD"
	absolutize_file_paths
	# build sw-desc fragments
	for desc; do
		[ -e "$desc" ] || error "%s does not exist" "$desc"
		cd "$(dirname -- "$desc")" || error "cannot enter %s directory" "$desc"
		[ "${desc%.desc}" != "$desc" ] || info "Warning: %s does not end in .desc, wrong file?" "$desc"
		component="${desc%.desc}"
		component=${component##*/}
		version=""
		install_if=""
		. "./${desc##*/}"
		# make key files path absolute after each iteration:
		# this is required if a desc file sets a key path
		absolutize_file_paths
		cd "$main_cwd" || error "Cannot return to %s we were in before" "$main_cwd"
		[ "$desc" != "$1" ] && info "Successfully included %s contents" "$desc"
	done

	[ -z "$FIRST_SWDESC_INIT" ] || [ -n "$FORCE_VERSION" ] \
		|| error "No or empty desc given?"

	embedded_postinstall_script
	write_sw_desc > "$OUTDIR/sw-description"
	# XXX debian's libconfig is obsolete and does not allow
	# trailing commas at the end of lists (allowed from 1.7.0)
	# probably want to sed these out at some point for compatibility
	# (Note this is only required to run swupdate on debian,
	#  not for image generation)
	mkcpio

	if [ -n "$COPY_USB" ]; then
		info "You have sideloaded containers, copy all these files to USB drive:"
		info "%s" "$(shell_quote "$(realpath "$OUT")") $COPY_USB"
		info
	fi

	cleanup_outdir

	info "Successfully generated %s" "$OUT"
}


# check if sourced: basename $0 should only be mkswu if run directly
[ "$(basename "$0")" != "mkswu" ] && return

mkimage "$@"

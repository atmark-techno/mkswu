#!/bin/sh

# disable noisy shellcheck warnings
# shellcheck disable=SC2039,SC1090,SC2165,SC2167,SC2064,SC2015
# shellcheck disable=SC2247,SC2119,SC1090,SC2120,SC3043,SC3013
# shellcheck disable=SC2016 # $ in single quotes on purpose

if command -v gettext >/dev/null; then
	_gettext() { TEXTDOMAINDIR="$TEXTDOMAINDIR" TEXTDOMAIN=mkswu gettext -- "$@"; }
else
	_gettext() { printf -- "%s" "$@"; }
fi

printmsg() {
	local level="$1"
	shift
	[ "$VERBOSE" -lt "$level" ] && return

	if [ "$#" = "0" ] || [ -z "$1" ]; then
		echo
		return
	fi

	local fmt="$1"
	shift
	# shellcheck disable=SC2059 # fmt is a build time constant
	printf -- "$(_gettext "$fmt")\n" "$@"
}

error() {
	if [ "$#" = "0" ] || [ -z "$1" ]; then
		error "Error called without format string!"
		exit 1
	fi

	local fmt="$1"
	shift
	# shellcheck disable=SC2059 # fmt is a build time constant
	printf -- "ERROR: $(_gettext "$fmt")\n" "$@" >&2
	exit 1
}

warning() {
	printmsg 1 "$@" >&2
}

info() {
	printmsg 2 "$@"
}

trace() {
	printmsg 3 "$@" >&2
}

debug() {
	printmsg 4 "$@" >&2
}

# dash doesn't handle read -s
# and even if it did we wouldn't have gettext wrapping
# so provide our own helper
prompt() {
	local var="$1"
	local prompt_fmt="$2"
	shift 2

	if [ -n "$PASS" ] && tty -s; then
		trap "stty echo" EXIT INT QUIT
		stty -echo
	fi

	# shellcheck disable=SC2059 # fmt is a build time constant
	printf -- "$(_gettext "$prompt_fmt") " "$@"
	read -r "${var?}"

	if [ -n "$PASS" ] && tty -s; then
		stty echo
		trap "" EXIT INT QUIT
		echo
	fi
}

prompt_yesno() {
	local default="$1"
	shift 1
	local yesno

	while true; do
		prompt yesno "$@"
		[ -n "$yesno" ] || yesno="$default"
		case "$yesno" in
		[Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|1)
			return 0;;
		[Nn]|[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|0)
			return 1;;
		esac
	done
}

usage() {
	info "Usage: %s [opts] desc [desc...]" "$0"
	info
	info "Options:"
	info "  -c, --config <conf>     path to config (default ~/mkswu/mkswu.conf)"
	info "  -o, --out <out.swu>     path to output file (default from first desc's name)"
	info "  --init                  walk through initial key and first image generation"
	info "  --import                import current directory's config and keys into config dir"
	info "  --genkey                toggle key generation mode (see below for suboptions)"
	info "  --show [--raw] <in.swu> print details about input swu"
	info "  --version               print version and exit"
	info "  desc                    image description file(s), if multiple are given"
	info "                          then the generated image will merge all the contents"
	info
	info "desc file syntax:"
	info "  descriptions are imperative declarations building an image, the following"
	info "  commands available (see README for details):"
	info "  - swdesc_boot <bootfile>"
	info "  - swdesc_tar <tar_file> [--dest <dest>]"
	info "  - swdesc_files [--basedir <basedir>] [--dest <dest>] <files>"
	info "  - swdesc_command '<cmd>'"
	info "  - swdesc_script <script>"
	info "  - swdesc_exec <file> '<cmd>' (file is \$1 in command)"
	info "  - swdesc_embed_container <image_archive>"
	info "  - swdesc_usb_container <image_archive>"
	info "  - swdesc_pull_container <image_url>"
	info
	info "In most cases --version <component> <version> should be set,"
	info "<component> must be extra_os.* in order to update rootfs"
	info
	info "Key generation options:"
	info "  --cn          common name for key (mandatory for signing key)"
	info "  --plain       generate signing key without encryption"
	info "  --aes         generate aes key instead of default rsa key pair"
}

write_line() {
	local line
	for line; do
		[ -z "$line" ] && continue
		printf "%*s%s\n" "$((0${line:+1}?indent:0))" "" "$line"
	done
}

reindent() {
	local padding file
	padding=$(printf "%*s" "${indent:-0}" "")

	for file; do
		[ -e "$file" ] || continue
		sed -e "s/^/$padding/" "$file"
	done
}


link() {
	local src="$1"
	local dest="$2"
	local existing

	track_used "$dest"

	src=$(readlink -e "$src") || error "Cannot find source file: %s" "$1"

	if [ -h "$dest" ]; then
		existing=$(readlink "$dest")
		[ "$src" = "$existing" ] && return
		rm -f "$dest" || error "Could not remove previous link at %s" "$dest"
	elif [ -e "$dest" ]; then
		check_validity "$dest" "$src" && return
	fi

	# files with hardlinks will mess up the order within the cpio,
	# and thus change the order in which components are installed
	# (e.g. rootfs after post script...)
	# workaround by copying file (reflinks are ok) instead if required
	if [ "$(stat -L -c %h "$src")" != 1 ]; then
		cp --reflink=auto -a "$src" "$dest" || error "Could not copy %s to %s" "$src" "$dest"
	else
		ln -s "$(readlink -e "$src")" "$dest" || error "Could not link %s to %s" "$dest" "$src"
	fi
}

gen_iv() {
	openssl rand -hex 16
}

encrypt_file() {
	local src="$1"
	local dest="$2"
	local iv="$3"

	openssl enc -aes-256-cbc -in "$src" -out "$dest" \
			-K "$ENCRYPT_KEY" -iv "$iv" \
		|| error "failed to encrypt %s" "$src"
}

decrypt_file() {
	local src="$1"
	local dest="${src%.enc}"
	[ "$dest" != "$src" ] || error "File must end in .enc"
	local iv tmp file=${src##*/}
	ivs="${src%/*}/sw-description-ivs"

	[ -e "$ivs" ] || error "ivs file %s does not exist" "$ivs"

	while read -r iv tmp; do
		[ "$tmp" != "$file" ] || break
	done < "$ivs"
	[ "$tmp" = "$file" ] || error "%s not found in %s" "$file" "$ivs"
	setup_encryption
	openssl enc -aes-256-cbc -d -in "$src" -out "$dest" \
			-K "$ENCRYPT_KEY" -iv "$iv" \
		|| error "failed to decrypt %s" "$src"

}

setup_encryption() {
	[ -z "$ENCRYPT_KEYFILE" ] && return
	[ -e "$ENCRYPT_KEYFILE" ] \
		|| error "AES encryption key %s was set but not found.\nPlease create it with genkey.sh --aes" \
			"$ENCRYPT_KEYFILE"
	ENCRYPT_KEY=$(cat "$ENCRYPT_KEYFILE")
	# XXX if sw-description gets encrypted, its iv is here
	ENCRYPT_KEY="${ENCRYPT_KEY% *}"
}

check_validity() {
	# Note that since this creates/updates validity file we must
	# not recreate file_out with an incomplete result

	local file_out="$1"
	shift
	local file_src stat=""

	track_used "$file_out.validity"

	# check validity with mtime/size for all source files
	for file_src; do
		stat="${stat:+$stat
}$(stat -L -c %n-%Y-%s "$file_src")" \
			|| error "Source file %s for %s does not exist" "$file_src" "$file_out"
	done

	[ "$(cat "$file_out.validity" 2>/dev/null)" = "$stat"  ] \
		&& [ -e "$file_out" ] && return

	rm -f "$file_out"
	echo "$stat" > "$file_out.validity"
	return 1
}

compress() {
	local file_src="$1"
	local file_out="$2"

	track_used "$file_src" "$file_out"
	check_validity "$file_out" "$file_src" && return

	ZSTD_CLEVEL="${ZSTD_CLEVEL:-10}" \
	zstd -q -o "$file_out.tmp" < "$file_src" \
		|| error "failed to compress %s" "$file_src"

	mv "$file_out.tmp" "$file_out" \
		|| error "Could not rename %s" "$file_out"
}

append_file() {
	printf "%s\n" "$FILES_FIRST" "$FILES" \
			| grep -q -x "$file" \
		&& return

	# we want to install anything marked base_os first,
	# because if base_os is written anything like swdesc_command
	# cannot run until baseos has been extracted
	if [ -n "$install_first" ] || [ "$component" = "base_os" ]; then
		FILES_FIRST="$FILES_FIRST
$file"
	else
		FILES="$FILES
$file"
	fi
}

write_entry_stdout() {
	local file_src="$1"
	local file="${file_src##*/}"
	local file_out="$OUTDIR/$file"
	local compress="$compress"
	local install_if="$install_if"
	shift
	local sha256="" iv="" err

	trace "Processing $file"
	[ -e "$file_src" ] || error "Missing source file: %s" "$file_src"

	if [ -n "$compress" ]; then
		# Check if already compressed
		case "$file" in
		*.tar.*)
			if [ "$compress" = force ]; then
				# Force decompression through swupdate.
				# Only gzip and zstd are supported
				case "$file" in
				*.gz) compress=zlib;;
				*.zst) compress=zstd;;
				*) compress="";;
				esac
			else
				# archive handle will handle it
				compress=""
			fi
			;;
		*.apk)
			# already compressed
			compress=""
			;;
		*.zst)
			compress=zstd
			;;
		*)
			# do not compress files < 128 bytes
			if [ "$(stat -L -c "%s" "$file_src")" -lt 128 ]; then
				compress=""
			else
				compress=zstd
				file="$file.zst"
				file_out="$file_out.zst"
				compress "$file_src" "$file_out"
				file_src="$file_out"
			fi
			;;
		esac
	fi

	if [ -n "$ENCRYPT_KEY" ] && [ -s "$file_src" ]; then
		file="$file.enc"
		file_out="$file_out.enc"
		# if we already had encrypted this file we must reuse the same iv
		if [ -e "$OUTDIR/sw-description-ivs" ]; then
			local tmp
			while read -r iv tmp; do
				[ "$tmp" != "$file" ] || break
			done < "$OUTDIR/sw-description-ivs"
			[ "$tmp" = "$file" ] || iv=""
		fi
		if [ -z "$iv" ]; then
			iv=$(gen_iv)
			# also write it out for scripts
			printf "%s\n" "$iv $file" >> "$OUTDIR/sw-description-ivs"
			track_used "$OUTDIR/sw-description-ivs"
			encrypt_file "$file_src" "$file_out" "$iv"
		fi
		[ -n "$iv" ] || error "Could not generate an iv to encrypt %s" "$file_src"
		file_src="$file_out"

	fi

	append_file "$file"

	[ "$file_src" = "$file_out" ] && track_used "$file_out" \
		|| link "$file_src" "$file_out"

	track_used "$file_out.sha256sum"

	if [ -e "$file_out.sha256sum" ]; then
		sha256=$(cat "$file_out.sha256sum")
		# check validity with mtime + size
		[ "${sha256#* }" = "$(stat -L -c %Y-%s "$file_out")" ] \
			|| sha256=""
		sha256="${sha256% *}"
	fi

	if [ -z "$sha256" ]; then
		sha256=$(sha256sum < "$file_out") \
			|| error "Checksumming %s failed" "$file_out"
		sha256=${sha256%% *}
		printf "%s\n" "$sha256 $(stat -L -c %Y-%s "$file_out")" > "$file_out.sha256sum"
	fi


	write_line "{"
	indent=$((indent+2))
	printf "%s\n" "$show_cmd" | sed -e "s/^/$(printf "%*s" "$indent" "")# /"
	write_line "filename = \"$file\";"
	if [ -n "$version" ]; then
		[ -n "$component" ] || error "version %s was set without associated component" "$version"
		if [ -z "$install_if" ]; then
			case "$component" in
			boot) install_if="different";;
			*) install_if="higher";;
			esac
		fi
		case "$install_if" in
		higher)
			local max
			# handle only x.y.z.t or x.y.z-t
			printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)?(\.[0-9]+)?(\.[0-9]*|-[A-Za-z0-9.]+)?$' \
				|| error "Version %s must be x.y.z.t (numbers < 65536 only) or x.y.z-t (x-z numbers only)" "$version"
			# ... and check for max values
			if [ "${version%-*}" = "${version}" ]; then
				# only dots, "old style version" valid for 16 bits, but now overflow
				# falls back to semver which is signed int but only for 3 elements
				if printf %s "${version}" | grep -qE '\..*\..*\.'; then
					max=65535
				else
					max=2147483647
				fi
				# base_os must be x.y.z-t format to avoid surprises
				# with semver prerelease field filtering
				[ "$component" = "base_os" ] \
					&& error "base_os version %s must be in x[.y[.z]]-t format" "$version"
			else
				# semver, signed int
				max=2147483647
			fi
			err=$(printf %s "$version" | tr '.-' '\n' | awk '
				/^[0-9]+$/ && $1 > '$max' {
					print "1 " $1;
					exit
				}
				/[0-9][a-zA-Z]|[a-zA-Z][0-9]/ {
					print "2 " $1;
					exit
				}')
			case "$err" in
			1\ *) error "version check failed for %s: %s must be <= %s" "$version" "${err#* }" "$max";;
			2\ *) error "version check failed for %s: %s must not mix alpha and digits, e.g.:\n\t1.2.3-rc.4\n\t1.2.3.4\n\t1.2.3-4" \
				"$version" "${err#* }";;
			esac
			;;
		different)
			# different still goes through integer parsing, but is more relaxed
			# as different ordering does not matter, and pure lexicographical
			# is also allowed... Who said painful ?...
			if printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)?(\.[0-9]+)?(\.[0-9]*|-[A-Za-z0-9.-]+)?$'; then
				# same max check as above without mixed alnum check
				local max=2147483647
				[ "${version%-*}" = "${version}" ] \
					&& printf %s "${version}" | grep -qE '\..*\..*\.' \
					&& max=65535
				err=$(printf %s "$version" | tr '.-' '\n' | awk '
					/^[0-9]+$/ && $1 > '$max' {
						print "1 " $1;
						exit
					}')
				case "$err" in
				1\ *) error "version check failed for %s: %s must be <= %s" "$version" "${err#* }" "$max";;
				esac
			else
				# versions with 5+ components, semvers with 4+ leading digits,
				# and the '+' part of semvers are completly ignored and will be
				# considered identical so should be refused.
				# Anything else should be string-compared and is ok.
				printf %s "$version" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]*(\.[0-9]+|-[A-Za-z0-9.-]+)?$' \
					&& error "version %s has too many digit components, please use somthing else" \
						"$version"
				printf %s "$version" | grep -qE '^[0-9]+(\.[0-9]+)*([+-][A-Za-z0-9.+-]+)?$' \
					&& error "metadata (+ part) in %s while valid semver are ignored by swupdate, please use something else" \
						"$version"
			fi
	 ;;
		*) error "install_if must be higher or different";;
		esac
		[ "${component#* }" = "$component" ] || error "component must not contain spaces (%s)" "$component"
		[ "${version#* }" = "$version" ] || error "version must not contain spaces (%s = %s)" "$component" "$version"
		write_line "name = \"$component\";" \
			   "version = \"$version\";" \
			   "install-if-${install_if} = true;"

		# remember version for scripts
		printf "%s\n" "$component $version $install_if ${board:-*}" >> "$OUTDIR/sw-description-versions"
	elif [ -n "$version" ]; then
		error "version %s was set without associated component" "$version"
	fi
	if [ -n "$main_version" ]; then
		[ -n "$component" ] && [ -n "$version" ] \
			|| error "%s requires --version to be set" "--main-version"
		write_line "# MAIN_COMPONENT $component" \
			   "# MAIN_VERSION $version"
	fi
	[ -n "$compress" ] && write_line "compressed = \"$compress\";"
	[ -n "$iv" ] && write_line "encrypted = true;" "ivt = \"$iv\";"
	write_line "installed-directly = true;"
	write_line "sha256 = \"$sha256\";"
	write_line "$@"

	indent=$((indent-2))
	write_line "},"
}

write_entry() {
	local outfile="$OUTDIR/sw-description-$1${board:+-$board}"
	shift

	# Running init here allows .desc files to override key elements
	# before the first swdesc_* statement
	if [ -n "$FIRST_SWDESC_INIT" ]; then
		FIRST_SWDESC_INIT=""
		setup_encryption
		embedded_preinstall_script
	fi

	write_entry_stdout "$@" >> "$outfile"
}

parse_swdesc() {
	local ARG SKIP=0 NOPARSE=""

	# first argument tells us what to parse for
	local CMD="$1"
	shift

	for ARG; do
		shift
		# skip previously used argument
		# using a for loop means we can't shift ahead
		if [ "$SKIP" -gt 0 ]; then
			SKIP=$((SKIP-1))
			continue
		fi
		# split --switch=value
		if [ "${ARG#--*=}" != "$ARG" ]; then
			set -- "${ARG#--*=}" "$@"
			ARG="${ARG%%=*}"
		fi
		case "$NOPARSE$ARG" in
		"-b"|"--board")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			board="$1"
			SKIP=1
			;;
		"-v"|"--version")
			[ $# -lt 2 ] && error "%s requires <component> <version> arguments" "$ARG"
			component="$1"
			version="$2"
			SKIP=2
			;;
		"--extra-os")
			[ "${component#extra_os.}" != "$component" ] || component="extra_os.$component"
			;;
		"--main-version")
			main_version=1
			;;
		"--install-if")
			install_if="$1"
			case "$install_if" in
			higher|different) ;;
			*) error "--install-if must be higher or different";;
			esac
			SKIP=1
			;;
		"--preserve-attributes")
			[ "$CMD" = "tar" ] || [ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files and swdesc_tar" "$ARG"
			preserve_attributes=1
			;;
		"-d"|"--dest")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			[ "$CMD" = "tar" ] || [ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files and swdesc_tar" "$ARG"
			dest="$1"
			SKIP=1
			;;
		"--basedir")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			[ "$CMD" = "files" ] \
				|| error "%s only allowed for swdesc_files" "$ARG"
			basedir="$1"
			SKIP=1
			;;
		--)
			# we can't break loop or we would reorder previously seen
			# arguments with the rest: just tell parsing to not parse anymore
			# setting NOPARSE here will make the case always fall to last element
			NOPARSE=1
			;;
		"-"*)
			error "%s is not a known %s argument" "$ARG" "swdesc_$CMD"
			;;
		*)
			set -- "$@" "$ARG"
			;;
		esac
	done
	case "$CMD" in
	boot)
		[ $# -eq 0 ] && [ -n "$BOOT" ] && return
		[ $# -eq 1 ] || error "swdesc_boot requires an argument\nUsage: swdesc_boot [options] boot_file"
		BOOT="$1"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $BOOT"
		;;
	boot_enc)
		[ $# -eq 0 ] && [ -n "$BOOT" ] && [ -n "$DEK_OFFSETS" ] && return
		[ $# -eq 2 ] || error "swdesc_boot_enc requires two arguments\nUsage: swdesc_boot_enc [options] boot_enc_file dek_offets_file"
		BOOT="$1"
		DEK_OFFSETS="$2"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $BOOT"
		;;
	boot_linux)
		[ $# -eq 0 ] && [ -n "$file" ] && return
		[ $# -eq 1 ] || error "swdesc_boot_linux requires an argument\nUsage: swdesc_boot_linux [options] boot_linux_file"
		file="$1"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $file"
		;;
	tar)
		[ $# -eq 0 ] && [ -n "$source" ] && return
		[ $# -eq 1 ] || error "swdesc_tar requires an argument\nUsage: swdesc_tar [options] file.tar"
		source="$1"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD${dest:+ --dest $dest}${preserve_attributes:+ --preserve-attributes} $source"
		;;
	files)
		[ $# -eq 0 ] && [ -n "$file" ] && [ -n "$tarfiles_src" ] && return
		[ $# -ge 1 ] || error "swdesc_files requires arguments\nUsage: swdesc_files [options] file [files...]"
		tarfiles_src="$(printf "%s\n" "$@")"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD${dest:+ --dest $dest}${preserve_attributes:+ --preserve-attributes} $(printf "%s " "$@")"
		;;
	command*)
		[ $# -eq 0 ] && [ -n "$cmd" ] && return
		[ $# -ge 1 ] || error "swdesc_command requires arguments\nUsage: swdesc_command [options] cmd [cmd..]"
		cmd=""
		for ARG; do
			cmd="${cmd:+$cmd && }$ARG"
		done
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $cmd"
		;;
	script*)
		[ $# -eq 0 ] && [ -n "$script" ] && return
		[ $# -ge 1 ] || error "swdesc_script requires arguments\nUsage: swdesc_script [options] script [args]"
		script="$1"
		shift
		for ARG; do
			cmd="${cmd:+$cmd }$(shell_quote "$ARG")"
		done
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $script $cmd"
		;;
	exec*)
		[ $# -eq 0 ] && [ -n "$cmd" ] && [ -n "$file" ] && return
		[ $# -ge 2 ] || error "swdesc_exec requires at least two arguments\nUsage: swdesc_exec [options] file command"
		file="$1"
		shift
		cmd=""
		for ARG; do
			cmd="${cmd:+$cmd && }$ARG"
		done
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $file $cmd"
		;;
	*container)
		[ $# -eq 0 ] && [ -n "$image" ] && return
		[ $# -eq 1 ] || error "%s requires an argument\nUsage: %s [options] image" "swdesc_$CMD" "swdesc_$CMD"
		image="$1"
		[ -n "$show_cmd" ] || show_cmd="swdesc_$CMD $image"
		;;
	*)
		error "Unhandled command %s" "$CMD"
		;;
	esac
}

pad_boot() {
	local file="${BOOT##*/}"
	local src="$BOOT"
	local size

	BOOT_SIZE=$(numfmt --from=iec "$BOOT_SIZE")
	BOOT="$OUTDIR/$file"

	if [ "$src" -ot "$BOOT" ]; then
		size=$(stat -L -c "%s" "$BOOT")
		if [ "$size" -eq "$BOOT_SIZE" ]; then
			# already up to date
			return
		fi
	fi

	size=$(stat -L -c "%s" "$src") || error "Cannot stat boot file: %s" "$src"
	if [ "$size" -gt "$BOOT_SIZE" ]; then
		error "BOOT_SIZE set smaller than boot file actual size"
	fi
	rm -f "$BOOT"
	cp "$src" "$BOOT"
	truncate -s "$BOOT_SIZE" "$BOOT"
}

swdesc_boot() {
	local BOOT="$BOOT" component=boot version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc boot "$@"

	[ -n "$BOOT_SIZE" ] && pad_boot

	[ "$component" = "boot" ] \
		|| error "Version component for swdesc_boot must be set to boot"
	if [ -z "$version" ]; then
		version=$(grep -m1 -aoE '20[0-9]{2}.[0-1][0-9]-[0-9a-zA-Z.-]*' "$BOOT") \
			|| error "Could not guess boot version in %s" "$BOOT"
	fi

	write_entry images "$BOOT" "type = \"raw\";" \
		"device = \"/dev/swupdate_bootdev\";"
}

swdesc_boot_enc() {
	local BOOT="$BOOT" DEK_OFFSETS="$DEK_OFFSETS" offsets
	local component=boot version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc boot_enc "$@"

	[ -n "$BOOT_SIZE" ] && pad_boot

	[ "$component" = "boot" ] \
		|| error "Version component for swdesc_boot must be set to boot"
	[ -n "$version" ] \
		|| error "Version must be set for swdesc_boot_encrypted"

	offsets=$(cat "$DEK_OFFSETS")
	[ -n "$offsets" ] \
		|| error "dek offset file %s was not readable or empty" "$DEK_OFFSETS"

	swdesc_exec_nochroot "$BOOT" \
		'[ -e /dev/swupdate_bootdev ]' \
		"fw_setenv $offsets" \
		'echo 0 > /sys/class/block/$(basename $(readlink /dev/swupdate_bootdev))/force_ro' \
		'dd if=$1 of=/dev/swupdate_bootdev bs=1M conv=fdatasync status=none' \
		'echo 1 > /sys/class/block/$(basename $(readlink /dev/swupdate_bootdev))/force_ro'
}


swdesc_boot_linux() {
	local component=boot_linux version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"
	local file=""

	parse_swdesc boot_linux "$@"

	[ "$component" = "boot_linux" ] \
		|| error "Version component for swdesc_boot_linux must be set to boot_linux"
	[ -n "$version" ] \
		|| error "Version must be set for swdesc_boot_linux"
	[ "$(stat -L -c %s "$file")" -lt "$((26 * 1024 * 1024))" ] \
		|| error "swdesc_boot_linux image must be at most 26MB big"

	swdesc_exec_nochroot "$file" \
		'[ -e /dev/swupdate_bootdev ]' \
		'echo 0 > /sys/class/block/$(basename $(readlink /dev/swupdate_bootdev))/force_ro' \
		'dd if=$1 of=/dev/swupdate_bootdev bs=1M seek=5 conv=fdatasync status=none' \
		'echo 1 > /sys/class/block/$(basename $(readlink /dev/swupdate_bootdev))/force_ro'
}

swdesc_tar() {
	local source="$source" dest="$dest"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"
	local preserve_attributes="$preserve_attributes"
	local target="/target"

	parse_swdesc tar "$@"

	case "$DEBUG_SWDESC" in
	*DEBUG_SKIP_SCRIPTS*) target="";;
	esac
	case "$component" in
	base_os|extra_os*)
		dest="${dest:-/}"
		if [ "${dest#/}" = "$dest" ]; then
			error "OS update must have an absolute dest (was: %s)" "$dest"
		fi
		;;
	*)
		dest="${dest:-/var/app/rollback/volumes}"
		case "$dest" in
		/var/app/rollback/volumes*|/var/app/volumes*)
			# ok
			;;
		/*)
			[ -n "$target" ] \
				&& error "OS is only writable for base/extra_os updates and dest (%s) is not within volumes. Use --extra-os." "$dest"
			;;
		..*|*/../*|*/..)
			error ".. is not allowed in destination path for volume update"
			;;
		*)
			dest="/var/app/rollback/volumes/$dest"
			;;
		esac
	esac

	# it doesn't make sense to not set preserve_attributes
	# for base_os updates: fix it
	if [ "$component" = "base_os" ] \
	    && [ -z "$preserve_attributes" ]; then
		info "Warning: automatically setting --preserve-attributes for base_os update" >&2
		preserve_attributes=1
	fi
	write_entry images "$source" "type = \"archive\";" \
		"path = \"$target$dest\";" \
		"properties: { create-destination = \"true\"; };" \
		"${preserve_attributes:+preserve-attributes = true;}"
}

set_file_from_content() {
	local content="$*"

	file="$(printf %s "$content" | tr -c '[:alnum:]' '_')"
	if [ "${#file}" -gt 40 ]; then
		file="$(printf %s "$file" | head -c 20)..$(printf %s "$file" | tail -c 20)"
	fi
	file="${file}_$(printf %s "$content" | sha1sum | cut -d' ' -f1)"
	file="$OUTDIR/${file}"
}

create_archive() {
	# updates '$file' with new filename
	# basedir, tarfiles_src must be set
	local tarfile_raw tarfile

	set --
	: > "$OUTDIR/tar.validity.tmp"
	for tarfile_raw in $tarfiles_src; do
		if [ -z "$basedir" ]; then
			[ -d "$tarfile_raw" ] \
				&& basedir="$tarfile_raw" \
				|| basedir=$(dirname "$tarfile_raw")
		fi
		tarfile=$(realpath -e -s --relative-to="$basedir" "$tarfile_raw") \
			|| error "%s does not exist" "$tarfile_raw"
		[ "${tarfile#../}" = "$tarfile" ] \
			|| error "%s is not inside %s" "$tarfile_raw" "$basedir"

		find "$tarfile_raw" -exec stat -c "%n-%Y-%s" {} + \
				| sort >> "$OUTDIR/tar.validity.tmp" \
			|| error "Could not create tar for %s" "$tarfile_raw"
		set -- "$@" "$tarfile"
		# tarfile is relative, renormalize it...
		[ "$tarfile" = "." ]  && tarfile=""
		track_used "$basedir/$tarfile"
	done

	if [ -z "$file" ]; then
		set_file_from_content "$basedir" "$dest" "$@"
		file="$file.tar"
	elif [ "${file#/}" = "$file" ]; then
		file="$OUTDIR/$file"
	fi

	track_used "$file" "$file.validity"
	if ! [ -e "$file" ] || ! cmp -s "$file.validity" "$OUTDIR/tar.validity.tmp"; then
		tar -cf "$file" -C "$basedir" "$@" \
			|| error "Could not create tar for %s" "$file"
		mv "$OUTDIR/tar.validity.tmp" "$file.validity" \
			|| error "Could not rename %s" "$file.validity"
	else
		rm "$OUTDIR/tar.validity.tmp"
	fi
}

swdesc_files() {
	local file="" dest="$dest" basedir="$basedir"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd
	local preserve_attributes="$preserve_attributes"
	local tarfiles_src="$tarfiles_src"
	local IFS="
"
	parse_swdesc files "$@"

	create_archive

	swdesc_tar "$file"
}


shell_quote() {
	# sh-compliant quote function from http://www.etalabs.net/sh_tricks.html
	printf %s "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/"
}
conf_quote() {
	# Double backslashes, escape double-quotes, replace newlines by \n
	# (the last operation requires reading all input into patternspace first)
	printf %s "$1" | sed  ':a;$!N;$!ba;s/\\/\\\\/g;s/"/\\"/g;s/\n/\\n/g'
}

swdesc_exec_nochroot() {
	local file="$file" cmd="$cmd" orig_file
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc exec_nochroot "$@"

	[ ! -s "$file" ] || [ "$cmd" != "${cmd#*\$1}" ] \
		|| error 'Using swdesc_exec_nochroot with a non-empty file, but not referring to it with $1'

	# allow multiple execs with same file if command changes
	# don't rename if no arguments for easier debugging
	if [ -n "$cmd" ] && [ "$cmd" != 'sh $1 ' ]; then
		orig_file="$file"
		set_file_from_content "$file" "$cmd"
		link "$orig_file" "$file"
	fi

	cmd="sh -c $(shell_quote "$cmd") --"

	write_entry files "$file" "type = \"exec\";" \
		"properties: {" \
		"  cmd: \"$(conf_quote "$cmd")\"" "}"
}

swdesc_exec() {
	local file="$file" cmd="$cmd" chroot_cmd orig_file
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc exec "$@"

	[ ! -s "$file" ] || [ "$cmd" != "${cmd#*\$1}" ] \
		|| error 'Using swdesc_exec with a non-empty file, but not referring to it with $1'

	case "$component" in
	base_os|extra_os*)
		chroot_cmd="podman run --net=host --rm"
		chroot_cmd="$chroot_cmd -v \${TMPDIR:-/var/tmp}:\${TMPDIR:-/var/tmp}"
		chroot_cmd="$chroot_cmd --rootfs /target sh -c $(shell_quote "$cmd") --"
		;;
	*)
		# If target is read-only we need special handling to run (silly podman tries
		# to write to / otherwise) but keep volumes writable
		chroot_cmd="podman run --net=host --rm --read-only -v /target/var/app/volumes:/var/app/volumes"
		chroot_cmd="$chroot_cmd -v /target/var/app/rollback/volumes:/var/app/rollback/volumes"
		chroot_cmd="$chroot_cmd -v \${TMPDIR:-/var/tmp}:\${TMPDIR:-/var/tmp}"
		chroot_cmd="$chroot_cmd --rootfs /target sh -c $(shell_quote "$cmd") -- "
		;;
	esac

	# allow multiple execs with same file if command changes
	# don't rename if no arguments for easier debugging
	if [ -n "$cmd" ] && [ "$cmd" != 'sh $1 ' ]; then
		orig_file="$file"
		set_file_from_content "$file" "$cmd"
		link "$orig_file" "$file"
	fi

	write_entry files "$file" "type = \"exec\";" \
		"properties: {" \
		"  cmd: \"$(conf_quote "$chroot_cmd")\"" "}"
}

swdesc_command() {
	local orig_cmd="swdesc_command $*"
	local cmd="$cmd" file
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc command "$@"

	set_file_from_content "$cmd"
	[ -e "$file" ] || : > "$file"

	swdesc_exec
}

swdesc_command_nochroot() {
	local orig_cmd="swdesc_command_nochroot $*"
	local cmd="$cmd" file
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc command_nochroot "$@"

	set_file_from_content "$cmd"
	[ -e "$file" ] || : > "$file"

	swdesc_exec_nochroot
}

swdesc_script() {
	local orig_cmd="swdesc_script $*"
	local script="$script"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"
	local cmd="$cmd"

	parse_swdesc script "$@"

	swdesc_exec "$script" 'sh $1'" $cmd"
}

swdesc_script_nochroot() {
	local script="$script"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"
	local cmd="$cmd"

	parse_swdesc script_nochroot "$@"

	swdesc_exec_nochroot "$script" 'sh $1'" $cmd"
}


swdesc_embed_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc embed_container "$@"

	swdesc_exec_nochroot "$image" '${TMPDIR:-/var/tmp}/scripts/podman_update -l $1'
}

swdesc_pull_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc pull_container "$@"

	swdesc_command_nochroot '${TMPDIR:-/var/tmp}/scripts/podman_update "'"$image"'"'
}

swdesc_usb_container() {
	local image="$image"
	local component="$component" version="$version"
	local board="$board" main_version="$main_version"
	local install_if="$install_if" show_cmd="$show_cmd"

	parse_swdesc usb_container "$@"

	local image_usb="${image##*/}"
	if [ "${image_usb%.tar.*}" != "$image_usb" ]; then
		info "Warning: podman does not handle compressed container images without an extra uncompressed copy"
		info "you might want to keep the archive as simple .tar"
	fi
	link "$image" "$OUTDIR/$image_usb"
	sign "$image_usb"
	COPY_USB="${COPY_USB:+$COPY_USB }$(shell_quote "$(realpath "$image")")"
	COPY_USB="$COPY_USB $(shell_quote "$(realpath "$OUTDIR/$image_usb.sig")")"

	swdesc_command_nochroot '${TMPDIR:-/var/tmp}/scripts/podman_update --pubkey /etc/swupdate.pem -l '"$image_usb"
}

append_certificates() {
	# USER_PUBKEYS is comma-separated unlike other tar sources
	local IFS="," cert user_certs=""
	local source="$file"
	file="$OUTDIR/scripts_extras.tar"

	# we handle certificates separately for user certs and
	# atmark updates.
	# We will add here:
	# - atmark certificates if any to certs_atmark/
	# - if UPDATE_CERTS is set any certs that was in PUBKEY
	# (so by now USER_PUBKEYS)... except if the cert is the known
	# onetime public keys that we don't want to add.
	# We need such a gating flag to avoid breaking users that
	# already added their own keys with another mechanism.

	case "$UPDATE_CERTS" in
	[Yy]|[Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|1)
		for cert in $USER_PUBKEYS; do
			[ -e "$cert" ] || continue
			# compare cert's pubkey with known onetime-public key
			if [ "$(openssl x509 -noout -in "$cert" -pubkey \
					| sed -e '/-----/d' | tr -d '\n')" \
			    != "MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEYTN7NghmISesYQ1dnby5YkocLAe2/EJ8OTXkx/xGhBVlJ57eGOovtPORd/JMkA6lWI0N/pD5p6eUGcwrQvRtsw==" ]; then
				user_certs="$cert${user_certs:+,$user_certs}"
			fi
		done
		;;
	[Nn]|[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|0|"") ;;
	*) error "Invalid value for %s: %s" UPDATE_CERTS "$UPDATE_CERTS";;
	esac

	if [ -z "$user_certs$ATMARK_CERTS" ]; then
		# no key to add
		link "$source" "$file"
		return
	fi

	track_used "$file"
	check_validity "$file" "$source" $ATMARK_CERTS $user_certs && return

	cp -a --reflink=auto "$source" "$file.tmp" \
		|| error "Could not copy %s to %s" "$source" "$file"

	for cert in $user_certs; do
		# prefix ./ if no other / in filename...
		[ "${cert%/*}" != "$cert" ] || cert="./$cert"
		tar -C "${cert%/*}" --append --transform 's:^:certs_user/:' -f "$file.tmp" "${cert##*/}" \
			|| error "Could not append %s to %s" "$cert" "$file.tmp"
	done
	for cert in $ATMARK_CERTS; do
		[ "${cert%/*}" != "$cert" ] || cert="./$cert"
		tar -C "${cert%/*}" --append --transform 's:^:certs_atmark/:' -f "$file.tmp" "${cert##*/}" \
			|| error "Could not append %s to %s" "$cert" "$file.tmp"
	done
	mv "$file.tmp" "$file" \
		|| error "Could not rename %s" "$file"
}

create_prescript() {
	# prescript is a self-extracting tar archive
	track_used "$file"

	check_validity "$file" "$PRE_SCRIPT" "$tar" && return

	cat "$PRE_SCRIPT" "$tar" > "$file.tmp" \
		&& mv "$file.tmp" "$file" \
		|| error "Could not create pre script"
}

embedded_preinstall_script() {
	local component="" version="" board="" main_version=""
	local install_if="" show_cmd="pre_script"
	local script="" cmd=""
	local install_first=1
	local EMBEDDED_SCRIPTS_DIR="$SCRIPT_DIR/scripts"
	local PRE_SCRIPT="$SCRIPT_DIR/scripts_pre.sh"

	local file="$OUTDIR/scripts.tar" basedir=""
	local tarfiles_src="$EMBEDDED_SCRIPTS_DIR"
	create_archive

	append_certificates

	local tar="$file"
	file="$OUTDIR/scripts_pre.sh"
	create_prescript

	swdesc_script_nochroot "$file"
}

embedded_postinstall_script() {
	local component="" version="" board="" main_version=""
	local install_if="" show_cmd="post_script"
	local script="" cmd=""
	local POST_SCRIPT="$SCRIPT_DIR/scripts_post.sh"

	swdesc_script_nochroot "$POST_SCRIPT"
}

swdesc_option() {
	local opt
	for opt; do
		case "$opt" in
		FORCE_VERSION) FORCE_VERSION=1;;
		POST_ACTION=*) POST_ACTION=${opt#POST_ACTION=};;
		NOTIFY_STARTING_CMD=*) NOTIFY_STARTING_CMD="${opt#NOTIFY_STARTING_CMD=}";;
		NOTIFY_FAIL_CMD=*) NOTIFY_FAIL_CMD="${opt#NOTIFY_FAIL_CMD=}";;
		NOTIFY_SUCCESS_CMD=*) NOTIFY_SUCCESS_CMD="${opt#NOTIFY_SUCCESS_CMD=}";;
		ROOTFS_FSTYPE=*) ROOTFS_FSTYPE="${opt#ROOTFS_FSTYPE=}";;
		BOOT_SIZE=*) BOOT_SIZE="${opt#BOOT_SIZE=}";;
		ENCRYPT_KEYFILE=*) ENCRYPT_KEYFILE="${opt#ENCRYPT_KEYFILE=}";;
		PUBKEY=*) PUBKEY="${opt#PUBKEY=}";;
		UPDATE_CERTS=*) UPDATE_CERTS="${opt#UPDATE_CERTS=}";;
		PRIVKEY=*) PRIVKEY="${opt#PRIVKEY=}";;
		PRIVKEY_PASS=*) PRIVKEY_PASS="${opt#PRIVKEY_PASS=}";;
		DESCRIPTION=*) DESCRIPTION="${opt#DESCRIPTION=}";;
		component=*) component="${opt#component=}";;
		version=*) version="${opt#version=}";;
		install_if=*) install_if="${opt#install_if=}";;
		CONTAINER_CLEAR|NO_PRESERVE_FILES|\
		ENCRYPT_ROOTFS|ENCRYPT_USERFS|\
		SKIP_APP_SUBVOL_SYNC|ALLOW_PUBLIC_CERT|ALLOW_EMPTY_LOGIN)
			SWDESC_OPTS="$SWDESC_OPTS
$opt";;
		*) error "Unknown option for swdesc_option: %s" "$opt";;
		esac
	done
}

write_sw_desc() {
	local indent=4
	local file line section board=""
	local board_hwcompat board_normalize
	local IFS="
"

	track_used "$OUTDIR/sw-description"

	[ -n "$DESCRIPTION" ] || error "DESCRIPTION must be set"
	cat <<EOF
software = {
  # Built with mkswu $MKSWU_VERSION
  version = "0.1.0";
  description = "$DESCRIPTION";
EOF

	# handle boards files first
	for file in "$OUTDIR/sw-description-"*-*; do
		[ -e "$file" ] || break
		board="${file#*sw-description-*-}"
		[ "$board" = "-" ] && continue
		track_used "$file"
		[ -e "$OUTDIR/sw-description-done-$board" ] && continue
		touch "$OUTDIR/sw-description-done-$board"
		board_normalize=$(printf %s "$board" | tr -c '[:alnum:]' '_')
		board_hwcompat=$(eval "printf %s \"\$HW_COMPAT_$board_normalize"\")
		[ -n "$board_hwcompat" ] || board_hwcompat="$HW_COMPAT"
		[ -n "$board_hwcompat" ] || error "HW_COMPAT or HW_COMPAT_%s must be set" "$board_normalize"
		indent=2 write_line "$board = {"
		indent=4 write_line "hardware-compatibility = [ \"$board_hwcompat\" ];"
		for file in "$OUTDIR/sw-description-"*"-$board"; do
			[ -s "$file" ] || continue
			# also include common section if any
			# XXX in case of duplicate here we should favor
			# current board's file and ignore second one instead
			# but it would be better with an explicit "board=none" kind
			# of syntax. The problem would be when to consider these
			# elements versions for sw-versions merging script, as we'd
			# need to check if a board matched first, so leave for later.
			check_duplicate_files "$file" "$OUTDIR/sw-description-$section"
			section=${file##*sw-description-}
			section=${section%%-*}
			indent=4 write_line "$section: ("
			indent=6 reindent "$file" "$OUTDIR/sw-description-$section"
			indent=4 write_line ");"
		done
		indent=2 write_line "};"
	done

	# only set global hardware-compatibility if no board specific ones found
	if [ -z "$board" ]; then
		[ -n "$HW_COMPAT" ] || error "HW_COMPAT must be set"
		echo "  hardware-compatibility = [ \"$HW_COMPAT\" ];"
	fi

	for file in "$OUTDIR/sw-description-"*; do
		board="${file##*sw-description-}"
		section="${board%-*}"
		[ "$section" = "$board" ] && board="" || board="${board#*-}"
	done

	# main sections for all boards
	for section in images files scripts; do
		file="$OUTDIR/sw-description-$section"
		[ -e "$file" ] || continue
		track_used "$file"
		check_duplicate_files "$file"
		indent=2 write_line "" "$section: ("
		indent=4 reindent "$file"
		indent=2 write_line ");"
	done

	# Store highest versions in special comments
	if [ -e "$OUTDIR/sw-description-versions" ]; then
		track_used "$OUTDIR/sw-description-versions"
		sort -u -k 1,1 -k 4,4 -k 1 < "$OUTDIR/sw-description-versions" \
				| sort -u -k 1,1 -k 4,4 -c \
			|| error "above component used multiple times with different versions or install-if mode"
		sort -u -k 1,1 -k 4,4 -k 1 < "$OUTDIR/sw-description-versions" \
				| sed -e 's/^/  #VERSION /'
	elif [ -z "$FORCE_VERSION" ]; then
		error "No versions found: empty image or version not set?"
	fi
	SWDESC_OPTS="$SWDESC_OPTS
${FORCE_VERSION:+FORCE_VERSION}
${CONTAINER_CLEAR:+CONTAINER_CLEAR}
${NO_PRESERVE_FILES:+NO_PRESERVE_FILES}"
	local option
	for option in $SWDESC_OPTS; do
		echo "  # MKSWU_$option 1"
	done
	[ -n "${NOTIFY_STARTING_CMD+1}" ] \
		&& echo "$NOTIFY_STARTING_CMD" | sed -e 's/^/  # MKSWU_NOTIFY_STARTING_CMD /'
	[ -n "${NOTIFY_FAIL_CMD+1}" ] \
		&& echo "$NOTIFY_FAIL_CMD" | sed -e 's/^/  # MKSWU_NOTIFY_FAIL_CMD /'
	[ -n "${NOTIFY_SUCCESS_CMD+1}" ] \
		&& echo "$NOTIFY_SUCCESS_CMD" | sed -e 's/^/  # MKSWU_NOTIFY_SUCCESS_CMD /'
	case "$ROOTFS_FSTYPE" in
	ext4|btrfs) echo "# MKSWU_ROOTFS_FSTYPE $ROOTFS_FSTYPE";;
	"") ;;
	*) error "invalid ROOTFS_FSTYPE \"%s\", must be empty, ext4 or btrfs" "$ROOTFS_FSTYPE";;
	esac
	case "$POST_ACTION" in
	poweroff|wait|container) echo " # MKSWU_POST_ACTION $POST_ACTION";;
	""|reboot) ;;
	*) error "invalid POST_ACTION \"%s\", must be empty, poweroff or wait" "$POST_ACTION";;
	esac

	# and also add extra debug comments
	for line in $DEBUG_SWDESC; do
		indent=2 write_line "$line"
	done


	indent=0 write_line "};"
}

check_common_mistakes() {
	local swdesc="$OUTDIR/$1"

	# grep for common patterns of easy mistakes that would fail installing
	! grep -qF '$6$salt$hash' "$swdesc" \
		|| error "Please set user passwords (usermod command in .desc)"
}

check_duplicate_files() {
	local file duplicates

	duplicates=$(for file; do
		[ -e "$file" ] || continue
		cat "$file"
	done | awk -F\" '
		/filename/ {
			if (seen[$2]) {
				print $2
			}
			seen[$2] = 1;
		}
	')

	[ -z "$duplicates" ] || error "Duplicate files detected in sw-description: duplicate swdesc_* commands?\n%s" "$duplicates"
}

sign() {
	local file="$OUTDIR/$1"

	track_used "$file.sig"

	check_validity "$file.sig" "$file" "$PUBKEY" "$PRIVKEY" && return
	[ -n "$PRIVKEY" ] || error "PRIVKEY must be set"
	[ -n "$PUBKEY" ] || error "PUBKEY must be set"
	[ -r "$PRIVKEY" ] || error "Cannot read PRIVKEY: %s" "$PRIVKEY"
	[ -r "$PUBKEY" ] || error "Cannot read PUBKEY: %s" "$PUBKEY"

	openssl cms -sign -in "$file" -out "$file.sig.tmp" \
		-signer "$PUBKEY" -inkey "$PRIVKEY" \
		-outform DER -nosmimecap -binary \
		${PRIVKEY_PASS:+-passin "$PRIVKEY_PASS"} \
		|| error "Could not sign %s" "$file"

	mv "$file.sig.tmp" "$file.sig" \
		|| error "Could not rename %s" "$file.sig"
}

verify() {
	# note: this is only a helper for debug
	local file="$1"
	openssl cms -verify -inform DER -in "$file.sig" -content "$file" \
		-nosmimecap -binary -CAfile "$PUBKEY" > /dev/null \
		|| error "Signature verification failed for $file"
	echo "$file: OK"
}

mkcpio() {
	FILES="${FILES_FIRST}${FILES}"

	check_common_mistakes sw-description
	sign sw-description
	(
		IFS="
"
		cd "$OUTDIR" || error "Could not enter %s" "$OUTDIR"
		# GNU gpio has a bug with checksums for files bigger than 2GB
		# https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=962188
		# fall back to newc in this case, we also compute sha256 for
		# every file so this isn't a big loss
		format=crc
		# shellcheck disable=SC2086 # we want split by newline
		if ! stat -L -c %s $FILES | awk '$1 > 2147483648 { exit 1; }'; then
			format=newc
		fi
		printf %s "$FILES" | cpio -o -H "$format" -L --quiet
	) > "$OUT" || error "Could not create SWU (cpio archive)"

	CPIO_FILES=$(cpio -t --quiet < "$OUT")
	[ "$CPIO_FILES" = "$FILES" ] \
		|| error "cpio does not contain files we requested (in the order we requested): check %s" "$OUT"
}

track_used() {
	local file

	for file; do
		# only track files inside outdir
		[ "${file#"$OUTDIR"}" = "$file" ] && continue

		if [ -d "$file" ]; then
			find "$file" -type f
		else
			printf "%s\n" "$file"
		fi >> "$OUTDIR/used_files"
	done
}

cleanup_outdir() {
	local file

	sort < "$OUTDIR/used_files" > "$OUTDIR/used_files.sorted"
	find "$OUTDIR" -not -type d | sort \
		| join -v 1 - "$OUTDIR/used_files.sorted" \
		| xargs -r rm -f

	# also remove any empty dir
	# busybox find does not have find -empty, but we have
	# GNU coreutils so we can use rm --ignore-fail-on-non-empty
	find "$OUTDIR" -depth -mindepth 1 -type d \
		-exec rmdir --ignore-fail-on-non-empty {} +
}

update_mkswu_conf() {
	local confbase="${CONFIG##*/}"
	local NEW_CONFIG="$CONFIG"

	if [ "$confbase" = mkimage.conf ]; then
		NEW_CONFIG="$(dirname "$CONFIG")/mkswu.conf"
		[ -e "$NEW_CONFIG" ] && error "Trying to convert from mkimage.conf to mkswu.conf, but mkswu.conf already exists!"
	fi

	[ -e "$CONFIG_DIR" ] || mkdir -vp "$CONFIG_DIR"

	# subshell to not source multiple versions of same file
	(
		set +e
		sha=$(sha256sum "$SCRIPT_DIR/mkswu.conf.defaults")
		sha=${sha%% *}
		if [ -e "$CONFIG" ]; then
			DEFAULTS_MKSWU_CONF_SHA256=$(sed -ne 's/DEFAULTS_\(MKIMAGE\|MKSWU\)_CONF_SHA256="\(.*\)"/\2/p' "$CONFIG")
			# config exist + no sha: don't update
			[ -z "$DEFAULTS_MKSWU_CONF_SHA256" ] && exit
			# sha didn't change: don't update
			[ "$DEFAULTS_MKSWU_CONF_SHA256" = "$sha" ] && exit

			# keep old version
			cp "$CONFIG" "$CONFIG.autosave-$(date +%Y%m%d)" \
				|| error "Could not update config %s" "$CONFIG"

			# update hash, trim comments/empty lines past auto section comment
			# and update obsolete header if still present
			sed -e "s/^DEFAULTS_\(MKSWU\|MKIMAGE\)_CONF_SHA256=.*/DEFAULTS_MKSWU_CONF_SHA256=\"$sha\"/" \
			    -e '/^## auto section/p' -e '/^## auto section/,$ {/^#\|^$/ d}' \
			    -e 's/^# defaults section: if you remove this include you must keep this file up/# defaults section: used to keep auto section comments below up to date/' \
			    -e 's/^# to date with mkimage.conf\(.defaults\)\? changes!/# if you remove it the file will not be edited again./' \
			    -e '/^\. .*mkimage.conf.defaults/d' \
			    "$CONFIG" > "$NEW_CONFIG.new" \
			    || error "Could not update config %s" "$CONFIG"
		else
			cat > "$NEW_CONFIG.new" <<EOF \
				|| error "Could not update config %s" "$CONFIG"
# defaults section: used to keep auto section comments below up to date
# if you remove it the file will not be edited again.
DEFAULTS_MKSWU_CONF_SHA256="$sha"

## user section: this won't be touched

## auto section: you can make changes here but comments will be lost
EOF
		fi

		sed -e 's/^[^#]/#&/' "$SCRIPT_DIR/mkswu.conf.defaults" >> "$NEW_CONFIG.new" \
			&& mv "$NEW_CONFIG.new" "$NEW_CONFIG" \
			|| error "Could not update config %s" "$CONFIG"

		info "Updated config file %s" "$NEW_CONFIG" >&2
	) || exit

	# if renamed, remove old config after all is done
	if [ "$CONFIG" != "$NEW_CONFIG" ] && [ -e "$NEW_CONFIG" ]; then
		rm -f "$CONFIG"
		CONFIG="$NEW_CONFIG"
	fi
}

mkswu_import() {
	# import standalone config file and its keys to $HOME/swu
	local NEW_CONFIG_DIR="${MKSWU_IMPORT_CONFIG_DIR:-$HOME/mkswu}"
	local NEW_CONFIG="$NEW_CONFIG_DIR/mkswu.conf"
	CONFIG_DIR="$(realpath "$(dirname "$CONFIG")")" \
		|| error "Could not resolve %s directory name" "$CONFIG"

	[ $# -gt 0 ] && error "--%s had extra arguments?" "$(mode_to_opt "$MODE")"
	if [ -e "$NEW_CONFIG" ]; then
		warning "Config %s already exists, skipping import" "$NEW_CONFIG"
		return
	fi

	info "Importing config %s and associated keys to %s" "$CONFIG" "$NEW_CONFIG_DIR"

	mkdir -vp "$NEW_CONFIG_DIR"
	for file in "$PRIVKEY" "$PUBKEY" "$ENCRYPT_KEYFILE"; do
		[ -z "$file" ] && continue
		[ -e "$file" ] \
			|| error "Key file %s could not be found, try setting absolute path in config file and reimport" "${file##*/}"

		cp -v "$file" "$NEW_CONFIG_DIR/" \
			|| error "Could not copy %s to %s" "$file" "$NEW_CONFIG_DIR/"
	done

	sed -e "s@^PRIVKEY=.*@PRIVKEY=\"\$CONFIG_DIR/$(basename "$PRIVKEY")\"@" \
	    -e "s@^PUBKEY=.*@PUBKEY=\"\$CONFIG_DIR/$(basename "$PUBKEY")\"@" \
	    -e "s@^ENCRYPT_KEYFILE=.*@ENCRYPT_KEYFILE=\"\$CONFIG_DIR/$(basename "$ENCRYPT_KEYFILE")\"@" \
	    "$CONFIG" > "$NEW_CONFIG" \
		|| error "Could not update config %s" "$NEW_CONFIG"

	info "Imported config %s to %s" "$CONFIG" "$NEW_CONFIG"
	info "You can know check mkswu works with new config and remove the old directory"
}

absolutize_file_paths() {
	[ "${PRIVKEY#/}" != "$PRIVKEY" ] || PRIVKEY=$(realpath "$PRIVKEY")
	[ "${PUBKEY#/}" != "$PUBKEY" ] || PUBKEY=$(realpath "$PUBKEY")
	[ -z "$ENCRYPT_KEYFILE" ] \
		|| [ "${ENCRYPT_KEYFILE#/}" != "$ENCRYPT_KEYFILE" ] \
		|| ENCRYPT_KEYFILE=$(realpath "$ENCRYPT_KEYFILE")
}

mkswu_genkey_aes() {
	local oldumask

	[ $# -gt 0 ] && error "--%s had extra arguments?" "$(mode_to_opt "$MODE")"
	if [ -z "$ENCRYPT_KEYFILE" ]; then
		info "Info: using default aes key path"
		ENCRYPT_KEYFILE="$CONFIG_DIR/swupdate.aes-key"
		printf "%s\n" '' '# Default encryption key path (set by genkey.sh)' \
			'ENCRYPT_KEYFILE="$CONFIG_DIR/swupdate.aes-key"' >> "$CONFIG" \
			|| error "Could not update %s in %s" "ENCRYPT_KEYFILE" "$CONFIG"
	fi
	while [ -s "$ENCRYPT_KEYFILE" ]; do
		if [ -n "$NOPROMPT" ]; then
			warning "%s already exists, skipping" "$ENCRYPT_KEYFILE"
			return
		fi
		prompt_yesno y "%s already exists, generate new key? [Y/n]" "$ENCRYPT_KEYFILE" \
			|| return
		# increment index, update config at the end
		local idx
		ENCRYPT_KEYFILE="${ENCRYPT_KEYFILE%.aes-key}"
		idx="${ENCRYPT_KEYFILE##*-}"
		case "$idx" in
		""|*[a-zA-Z/]*) idx=1;;
		*)
			ENCRYPT_KEYFILE="${ENCRYPT_KEYFILE%-"$idx"}"
			;;
		esac
		idx=$((idx+1))
		ENCRYPT_KEYFILE="${ENCRYPT_KEYFILE}-$idx.aes-key"
		extrakey=1
	done

	oldumask=$(umask)
	umask 0377
	ENCRYPT_KEY="$(openssl rand -hex 32)" || error "Generating random number failed"
	printf "%s\n" "$ENCRYPT_KEY $(openssl rand -hex 16)" > "$ENCRYPT_KEYFILE"
	umask "$oldumask"

	info "Created encryption keyfile %s" "$ENCRYPT_KEYFILE"

	if [ -n "$extrakey" ]; then
		info "Info: Adding %s to config" "$ENCRYPT_KEYFILE"
		NEWKEY="${ENCRYPT_KEYFILE#"$CONFIG_DIR"}"
		if [ "$NEWKEY" != "$ENCRYPT_KEYFILE" ]; then
			NEWKEY="\$CONFIG_DIR/${NEWKEY#/}"
		fi
		printf "%s\n" '' '# extra encryption key. Remove the old one and use new' \
				'# ENCRYPT_KEYFILE after having installed an update with this first' \
				"NEW_ENCRYPT_KEYFILE=\"$NEWKEY\"" >> "$CONFIG" \
			|| error "Could not update %s in %s" "NEW_ENCRYPT_KEYFILE" "$CONFIG"
	fi

	info "You must also enable aes encryption with initial_setup.desc or equivalent"
}

mkswu_genkey_sign() {
	local oldumask extrakey=""
	local CURVE="${GENKEY_CURVE:-secp256k1}"
	local DAYS="${GENKEY_DAYS:-$((5*365))}"
	local NEWCERT ORIGCERT="$PUBKEY"

	[ $# -gt 0 ] && error "--%s had extra arguments?" "$(mode_to_opt "$MODE")"
	[ -n "$PRIVKEY" ] || error "PRIVKEY is not set in config file"
	[ -n "$PUBKEY" ] || error "PUBKEY is not set in config file"
	[ -z "$NOPROMPT" ] || [ -n "$GENKEY_CN" ] \
		|| error "%s must be set if using %s" "--cn" "--noprompt"

	while [ -s "$PRIVKEY" ] && [ -s "$PUBKEY" ]; do
		if [ -n "$NOPROMPT" ]; then
			warning "%s already exists, skipping" "$PRIVKEY"
			return
		fi
		prompt_yesno y "%s already exists, generate new key pair? [Y/n]" "$PRIVKEY" \
			|| return
		# increment index, update config at the end
		local idx
		PRIVKEY="${PRIVKEY%.key}"
		PUBKEY="${PUBKEY%.pem}"
		idx="${PRIVKEY##*-}"
		case "$idx" in
		""|*[a-zA-Z/]*) idx=1;;
		*)
			PRIVKEY="${PRIVKEY%-"$idx"}"
			PUBKEY="${PUBKEY%-"$idx"}"
			;;
		esac
		idx=$((idx+1))
		PRIVKEY="${PRIVKEY}-$idx.key"
		PUBKEY="${PUBKEY}-$idx.pem"
		extrakey=1
	done

	while [ -z "$GENKEY_CN" ]; do
		prompt GENKEY_CN "Enter certificate common name:"
	done

	info "Creating signing key %s and its public counterpart %s" "$PRIVKEY" "${PUBKEY##*/}"

	openssl req -x509 -newkey ec -pkeyopt ec_paramgen_curve:"$CURVE" \
		-keyout "$PRIVKEY" -out "$PUBKEY" -subj "/O=SWUpdate/CN=$GENKEY_CN" \
		${GENKEY_PLAIN:+-nodes} ${PRIVKEY_PASS:+-passout $PRIVKEY_PASS} \
		-days "$DAYS" || error "Generating certificate/key pair failed"

	if [ -n "$extrakey" ]; then
		info "Info: Adding %s to config" "$PUBKEY"
		NEWCERT="${PUBKEY#"$CONFIG_DIR"}"
		if [ "$NEWCERT" != "$PUBKEY" ]; then
			NEWCERT="\$CONFIG_DIR/${NEWCERT#/}"
		fi
		printf "%s\n" '' '# extra swupdate certificate. Remove the old one and use new' \
				'# PRIVKEY after having installed an update with this first' \
				"PUBKEY=\"\$PUBKEY,$NEWCERT\"" \
				'# remove "NEW_" to use' \
				"NEW_PRIVKEY=\"${NEWCERT%.pem}.key\"" >> "$CONFIG" \
			|| error "Could not update %s in %s" "NEW_PRIVKEY" "$CONFIG"
		case "$UPDATE_CERTS" in
		[Nn]|[Nn][Oo]|[Ff][Aa][Ll][Ss][Ee]|0|"")
			printf "%s\n" "# This controls if we should update certificates on device," \
					"# and can be removed once all devices have been updated to only allow new key" \
					"UPDATE_CERTS=yes" >> "$CONFIG" \
				|| error "Could not update %s in %s" "UPDATE_CERTS" "$CONFIG"
			;;
		esac
	fi

	info "%s will be copied over to /etc/swupdate.pem when installing newly generated swu" "$PUBKEY"
	info "You will then be able to remove the previous key by editing %s" "$CONFIG"
}

mkswu_internal() {
	[ $# -lt 1 ] && error "%s requires an argument" "--internal"
	local command="$1"
	shift
	case "$command" in
	get_var)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		local var val
		for var; do
			case "$var" in
			*[!0-9a-zA-Z_]*) error "Invalid variable name %s" "$var";;
			esac
			# check if set
			eval 'val=${'"$var"'+1}'
			[ -n "$val" ] || error "Variable %s was not set" "$var"
			eval 'val=$'"$var"
			printf "%s=%s\n" "$var" "$val"
		done
		;;
	sign)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		local file
		for file; do
			[ -e "$file" ] || error "%s does not exist" "$file"
			OUTDIR=$(dirname "$file")
			sign "$(basename "$file")"
		done
		;;

	verify)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		local file
		for file; do
			[ -e "$file" ] || error "%s does not exist" "$file"
			[ -e "$file.sig" ] || error "%s does not exist" "$file.sig"
			verify "$file"
		done
		;;
	decrypt)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		local file
		for file; do
			decrypt_file "$file"
		done
		;;
	mkcpio)
		[ $# -lt 1 ] && error "%s requires an argument" "--internal $command"
		OUT="$1"
		[ "${OUT%.swu}" != "$OUT" ] || error "%s must end with .swu" "$OUT"
		OUTDIR=$(dirname -- "$OUT")/.$(basename -- "$OUT" .swu)
		shift
		FILES_FIRST=""
		if [ $# -eq 0 ]; then
			[ -e "$OUT" ] || error "%s does not exist" "$OUT"
			FILES="$(cpio -t --quiet < "$OUT")"
			info "Packing:\n%s" "$FILES"
		else
			FILES=$(printf "%s\n" "$@")
		fi
		mkcpio
		info "Successfully generated %s" "$OUT"
		;;
	*)
		error "Unrecognized internal command %s" "$command"
		;;
	esac
}

mkinit_genkey() {
	local GENKEY_CN
	local KEYPASS KEYPASS_CONFIRM

	[ -e "$PUBKEY" ] && [ -e "$PRIVKEY" ] && return

	while [ -z "$GENKEY_CN" ]; do
		prompt GENKEY_CN "Enter certificate common name:"
	done

	while true; do
		PASS=1 prompt KEYPASS "Enter private key password (4-1024 char)"
		if [ -z "$KEYPASS" ]; then
			info "Empty key password is not recommended, re-enter empty to confirm"
		elif [ "${#KEYPASS}" -lt 4 ] || [ "${#KEYPASS}" -gt 1024 ]; then
			info "Must be between 4 and 1024 characters long"
			continue
		fi
		PASS=1 prompt KEYPASS_CONFIRM "private key password (confirm):"
		if [ "$KEYPASS" != "$KEYPASS_CONFIRM" ]; then
			info "Passwords do not match"
			continue
		fi
		break
	done

	if [ -n "$KEYPASS" ]; then
		echo "$KEYPASS" | PRIVKEY_PASS="stdin" \
			VERBOSE=1 NOPROMPT=1 mkswu_genkey_sign
	else
		GENKEY_PLAIN=1 VERBOSE=1 NOPROMPT=1 mkswu_genkey_sign
	fi || exit 1

	# Also prompt for encryption
	local AES

	[ -n "$ENCRYPT_KEYFILE" ] && [ -e "$ENCRYPT_KEYFILE" ] && return

	if prompt_yesno n "Use AES encryption? (N/y)"; then
		VERBOSE=1 mkswu_genkey_aes
		info "Generated %s" "$ENCRYPT_KEYFILE"
	fi
}

geninitdesc_hashpw() {
	local plain="$1"

	if command -v python3 >/dev/null; then
		printf 'import crypt; print(crypt.crypt(r"%s", crypt.METHOD_SHA512))' "$plain" | python3
	elif command -v mkpasswd >/dev/null; then
		printf "%s" "$plain" | mkpasswd
	else
		error "No command to hash password"
	fi
}

geninitdesc_promptpass() {
	local user="$1"
	local password
	local confirm

	while true; do
		if [ "$user" = "root" ]; then
			PASS=1 prompt password "%s user password:" "$user"
			if [ -z "$password" ]; then
				info "A root password is required"
				continue
			fi
		else
			PASS=1 prompt password "%s user password (empty = locks account):" "$user"
		fi
		PASS=1 prompt confirm "%s user password (confirm):" "$user"
		if [ "$password" != "$confirm" ]; then
			info "Passwords do not match"
			continue
		fi
		if [ -z "$password" ]; then
			password="-L"
		else
			password=$(echo "$password" | sed -e "s/\"/\"'\"'r/")
			password=$(geninitdesc_hashpw "$password")
			[ -n "$password" ] || error "Could not generate password"
			password="-p '\"'$password'\"'"
		fi
		break
	done
	PASSWD="$password"
}

geninitdesc_fixinitdesc() {
	local version
	version=$(sed -ne 's/.*version=\([0-9]*\).*/\1/p' "$desc")
	if [ -z "$version" ]; then
		echo "initial_setup.desc is too old, regenerating it"
		echo "old initial_setup.desc is kept in %s" "$desc.old"
		mv "$desc" "$desc.old" || error "Could not rename %s" "$desc"
		return 1
	fi

	if [ "$version" -le 1 ]; then
		info "atmark password was incorrectly generated, regenerating it"
		info "if initial_setup was already installed please adjust password"
		info "with %s if necessary" "$SCRIPT_DIR/examples/reset_atmark_pass.desc"

		local PASSWD
		geninitdesc_promptpass atmark

		sed -i -e 's:\(^[ \t]*"usermod\).*atmark:\1 '"$PASSWD"' atmark:' \
				-e 's/version=[0-9]*/version=2/' \
				"$desc" \
			|| error "Could not update %s" "$desc"
	fi
}

mkinit_geninitdesc() {
	local KEEPATMARKPEM
	local AUTOUPDATE=""
	local PASSWD
	local ROOTPW
	local ATMARKPW
	local desc="$CONFIG_DIR/initial_setup.desc"

	[ -e "$desc" ] && geninitdesc_fixinitdesc && return

	prompt_yesno y "Allow updates signed by Atmark Techno? (Y/n)" && KEEPATMARKPEM=1

	geninitdesc_promptpass "root"
	ROOTPW="$PASSWD"
	geninitdesc_promptpass "atmark"
	ATMARKPW="$PASSWD"

	# cleanup if we fail here
	trap "rm -f $desc.tmp" EXIT

	cp "$SCRIPT_DIR/examples/initial_setup.desc" "$desc.tmp" \
		|| error "Could not copy initial_setup.desc from example dir"
	if [ -z "$KEEPATMARKPEM" ]; then
		sed -i -e 's@^#\(.*> /etc/swupdate.pem\)@\1@' "$desc.tmp" \
			|| error "Could not update %s" "$desc.tmp"
	fi

	sed -i -e 's:\(^[ \t]*"usermod\).*atmark:\1 '"$ATMARKPW"' atmark:' \
			-e 's:\(^[ \t]*"usermod\).*root:\1 '"$ROOTPW"' root:' "$desc.tmp" \
		|| error "Could not update %s" "$desc.tmp"

	if [ -n "$KEEPATMARKPEM" ] && \
	    prompt_yesno n "Enable auto-update of BaseOS image from armadillo.atmark-techno.com servers? (N/y)"; then

		while true; do
			prompt AUTOUPDATE "Select update frequency ([weekly]/daily)"
			case "$AUTOUPDATE" in
			weekly|"")
				AUTOUPDATE="next week"; break;;
			daily)
				AUTOUPDATE="tomorrow"; break;;
			esac
		done
		cat >> "$desc.tmp" <<EOF \
			|| error "Could not update %s" "$desc.tmp"

# autoupdate
swdesc_command 'rc-update add swupdate-url default' \
	'if ! [ -e /etc/swupdate.watch ]; then
		case "\$(cat /etc/hwrevision)" in
		iot-a6e*) echo https://download.atmark-techno.com/armadillo-iot-a6e/image/baseos-6e-latest.swu > /etc/swupdate.watch;;
		*) echo "swupdate.watch should already have content" >&2 ; exit 1;;
		esac;
	fi' \
	'echo -e "schedule=\"0 $AUTOUPDATE\"\nrdelay=21600" > /etc/conf.d/swupdate-url'
EOF
	fi

	mv "$desc.tmp" "$desc" \
		|| error "Could not rename %s" "$desc"
	trap "" EXIT
}

mkinit_mkimageinitswu() {
	"$0" --config-dir "$CONFIG_DIR" --config "$CONFIG" \
			"$CONFIG_DIR/initial_setup.desc" \
		|| error "Could not generate initial setup swu"
	echo
	info "You can use \"%s\" as is or" "$CONFIG_DIR/initial_setup.swu"
	info "regenerate an image with extra modules using the following command:"
	info "  mkswu \"%s\" [other_desc_files]" \
		"$CONFIG_DIR/initial_setup.desc"
	info
	info "Note that once installed, you must preserve this directory as losing"
	info "key files means you will no longer be able to install new updates without"
	info "manually adjusting /etc/swupdate.pem on devices"
}


mkswu_init() {
	mkinit_genkey
	mkinit_geninitdesc
	mkinit_mkimageinitswu
}

mkswu_show() {
	local swu desc
	for swu; do
		[ "$swu" != "${swu%.swu}" ] \
			|| error "File does not end in .swu: %s" "$swu"

		printf "%s\n\n" "$swu"

		desc=$(cpio -i --quiet --to-stdout sw-description < "$swu")
		[ -n "$desc" ] || error "Could not get swu sw-description content from %s" "$swu"

		# default to raw for old swu generated before command hints
		if ! printf "%s\n" "$desc" | grep -q '# swdesc'; then
			info "SWU was build with an old version of mkswu or was empty,"
			info "falling back to --raw"
			echo
			SHOW_RAW=1
		fi
		if [ -n "$SHOW_RAW" ]; then
			printf "%s\n" "$desc"
			continue
		fi

		printf "%s\n" "$desc" | awk '
			/^ *# Built with mkswu/ {
				print "# built with mkswu", $NF
			}
			/^ *# swdesc_/ {
				sub(/ *# /, "")
				cmd=$0
				if (seen[cmd]) {
					cmd=""
				} else {
					seen[cmd]=1
				}
			}
			/^ *version =/ && cmd {
				gsub(/.*= "|";/, "")
				version[cmd]=$0
			}
			/^ *name =/ && cmd {
				gsub(/.*= "|";/, "")
				component[cmd]=$0
			}
			/^ *encrypted = true/ && cmd {
				encrypted[cmd]="1"
			}
			/^ *install-if-different/ {
				install_if[cmd]="different"
			}
			/^ *}/ && cmd {
				cmd=""
			}
			/^ *# MKSWU_/ {
				sub(/ *# MKSWU_/, "swdesc_option ")
				sub(/ 1$/, "")
				print
			}
			END {
				for (cmd in seen) {
				print ""
				print cmd
				if (component[cmd] && version[cmd]) {
					print "  --version", component[cmd], version[cmd]
					if (install_if[cmd]) {
						print "  --install-if", install_if[cmd]
					}
				}
				if (encrypted[cmd]) {
					print "  (encrypted)"
				}
			}
			}
			'
	done
}

mode_to_opt() {
	case "$1" in
	genkey*) echo "genkey";;
	*) echo "$1";;
	esac
}

mkimage() {
	local SCRIPT_DIR
	SCRIPT_DIR="$(cd -P -- "$(dirname -- "$0")" && pwd -P)" || error "Could not get script dir"
	local OUT=""
	local OUTDIR=""
	local CONFIG_DIR
	local CONFIG
	local FILES_FIRST="sw-description
sw-description.sig"
	local FILES=""
	local FIRST_SWDESC_INIT=1
	local COPY_USB=""
	local MODE=""
	local VERBOSE=2
	local TEXTDOMAINDIR="$SCRIPT_DIR/locale"
	local MKSWU_VERSION=""

	# config file variables
	local PRIVKEY PUBKEY PRIVKEY_PASS
	local USER_PUBKEYS="" ATMARK_CERTS="" UPDATE_CERTS=""
	local ENCRYPT_KEYFILE HW_COMPAT DESCRIPTION

	# mode options
	local GENKEY_PLAIN="" GENKEY_CN=""
	local SHOW_RAW=""
	local NOPROMPT=""

	# default default values
	local BOOT_SIZE="4M"
	local compress=1
	local main_cwd desc desc_file
	local component version board="" dest=""
	local install_first="" main_version="" show_cmd=""

	set -e

	if [ "${SCRIPT_DIR%/usr/bin}" != "$SCRIPT_DIR" ]; then
		SCRIPT_DIR=${SCRIPT_DIR%/bin}/share/mkswu
		TEXTDOMAINDIR="${SCRIPT_DIR%/mkswu}/locale"
	fi

	for CONFIG_DIR in "$SCRIPT_DIR" "$HOME/mkswu"; do
		for CONFIG in mkswu.conf mkimage.conf; do
			if [ -e "$CONFIG_DIR/$CONFIG" ]; then
				CONFIG="$CONFIG_DIR/$CONFIG"
				break 2
			fi
		done
	done
	# not found if doesn't start with /
	# just checking for -e $CONFIG would find ./mkimage.conf...
	[ "${CONFIG#/}" != "$CONFIG" ] \
		|| CONFIG="$CONFIG_DIR/mkswu.conf"

	if [ -z "$MKSWU_VERSION" ]; then
		if [ -e "$SCRIPT_DIR/.git" ]; then
			MKSWU_VERSION="$(git --git-dir "$SCRIPT_DIR/.git" describe)"
		elif [ -e "$SCRIPT_DIR/.version" ]; then
			MKSWU_VERSION=$(cat "$SCRIPT_DIR/.version")
		else
			error "mkswu not installed and could not guess mkswu version from git"
		fi
	fi

	local ARG SKIP=0
	for ARG; do
		# skip previously used argument
		# using a for loop means we can't shift ahead
		if [ "$SKIP" -gt 0 ]; then
			SKIP=$((SKIP-1))
			continue
		fi
		if [ "$SKIP" -lt 0 ]; then
			set -- "$@" "$ARG"
			continue
		fi

		shift
		# split --switch=value
		if [ "${ARG#--*=}" != "$ARG" ]; then
			set -- "${ARG#--*=}" "$@"
			ARG="${ARG%%=*}"
		fi
		case "$ARG" in
		"-c"|"--config")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			CONFIG="$(realpath -e "$1")" \
				|| error "%s does not exist" "$1"
			CONFIG_DIR="${CONFIG%/*}"
			[ -n "$CONFIG_DIR" ] || CONFIG_DIR=/
			SKIP=1
			;;
		"--config-dir")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			CONFIG_DIR="$1"
			CONFIG="$1/mkswu.conf"
			SKIP=1
			;;
		"-o"|"--out")
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			OUT="$1"
			[ "${OUT%.swu}" != "$OUT" ] || error "%s must end with .swu" "$OUT"
			SKIP=1
			;;
		"-vv"*)
			ARG=${ARG#-}
			while [ "${ARG#v}" != "$ARG" ]; do
				ARG="${ARG#v}"
				VERBOSE=$((VERBOSE+1))
			done
			[ -z "$ARG" ] || error "Only v can be repeated in -vvv..."
			;;
		"-v"|"--verbose")
			VERBOSE=$((VERBOSE+1))
			;;
		"-qq"*)
			ARG=${ARG#-}
			while [ "${ARG#q}" != "$ARG" ]; do
				ARG="${ARG#q}"
				VERBOSE=$((VERBOSE-1))
			done
			[ -z "$ARG" ] || error "Only q can be repeated in -qqq..."
			;;
		"-q"|"--quiet")
			VERBOSE=$((VERBOSE-1))
			;;
		"--mkconf")
			update_mkswu_conf
			exit 0
			;;
		"--init")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$(mode_to_opt "$MODE")"
			MODE=init
			;;
		"--import")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$(mode_to_opt "$MODE")"
			MODE=import
			# for import mode, also use config in current directory if
			# another one wasn't already found/set
			if ! [ -e "$CONFIG" ]; then
				[ -e "mkimage.conf" ] && CONFIG="$PWD/mkimage.conf"
				[ -e "mkswu.conf" ] && CONFIG="$PWD/mkswu.conf"
				CONFIG_DIR="$PWD"
			fi
			;;
		"--internal")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$(mode_to_opt "$MODE")"
			MODE=internal
			;;
		"--update-version")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$(mode_to_opt "$MODE")"
			MODE=update_version
			;;
		"--show")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$(mode_to_opt "$MODE")"
			MODE=show
			;;
		"--raw")
			[ "$MODE" = "show" ] || error "%s must be passed after %s" "$ARG" "--show"
			SHOW_RAW=1
			;;
		"--genkey")
			[ -z "$MODE" ] || error "%s is incompatible with --%s" "$ARG" "$(mode_to_opt "$MODE")"
			MODE=genkey_sign
			;;
		"--aes")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after %s" "$ARG" "--genkey"
			MODE=genkey_aes
			;;
		"--plain")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after %s" "$ARG" "--genkey"
			GENKEY_PLAIN=1
			;;
		"--cn")
			[ "$MODE" = "genkey_sign" ] || error "%s must be passed after %s" "$ARG" "--genkey"
			[ $# -lt 1 ] && error "%s requires an argument" "$ARG"
			GENKEY_CN="$1"
			SKIP=1
			;;
		"--noprompt")
			[ "$MODE" = "genkey_sign" ] || [ "$MODE" = "genkey_aes" ] \
				|| error "%s must be passed after %s" "$ARG" "--genkey"
			NOPROMPT=1
			;;
		"--version")
			info "mkswu version %s" "$MKSWU_VERSION"
			exit 0
			;;
		"--")
			# stop parsing
			SKIP=-1
			;;
		"-h"|"--help")
			usage
			exit 0
			;;
		"-")
			# single dash is stdin, treat it as normal file
			# (duplicate to handle unrecognized options)
			set -- "$@" "$ARG"
			;;
		"-"*)
			error "Unrecognized option %s" "$ARG"
			;;
		*)
			set -- "$@" "$ARG"
			;;
		esac
		[ "$SKIP" -gt 0 ] && shift "$SKIP"
	done

	. "$SCRIPT_DIR/mkswu.conf.defaults"
	if [ "$MODE" = "import" ] && ! [ -e "$CONFIG" ]; then
		error "Could not find config file to import, specify it with --config"
	fi
	if [ -z "$MODE" ] && ! [ -e "$CONFIG" ]; then
		[ -e "mkimage.conf" ] && error "Please import current config with mkswu --import first"
		error "Config file not found, create one with mkswu --init"
	fi
	if [ -n "$CONFIG" ]; then
		trace "Loading config %s" "$CONFIG"
		update_mkswu_conf
		[ -e "$CONFIG" ] || error "%s does not exist" "$CONFIG"
		[ "${CONFIG#/}" = "$CONFIG" ] && CONFIG="./$CONFIG"
		. "$CONFIG"
	fi
	# Force config values from env
	[ -n "${MKSWU_PRIVKEY+1}" ] && PRIVKEY="$MKSWU_PRIVKEY"
	[ -n "${MKSWU_PUBKEY+1}" ] && PUBKEY="$MKSWU_PUBKEY"
	[ -n "${MKSWU_PRIVKEY_PASS+1}" ] && PRIVKEY_PASS="$MKSWU_PRIVKEY_PASS"
	[ -n "${MKSWU_ENCRYPT_KEYFILE+1}" ] && ENCRYPT_KEYFILE="$MKSWU_ENCRYPT_KEYFILE"
	[ -n "${MKSWU_HW_COMPAT+1}" ] && HW_COMPAT="$MKSWU_HW_COMPAT"
	[ -n "${MKSWU_DESCRIPTION+1}" ] && DESCRIPTION="$MKSWU_DESCRIPTION"

	# split PUBKEY into actually used certificate and extra ones
	USER_PUBKEYS="$PUBKEY"
	PUBKEY="${PUBKEY%%,*}"

	if [ -n "$MODE" ]; then
		[ -n "$OUT" ] && error "%s is incompatible with --%s" "out" "$(mode_to_opt "$MODE")"
		"mkswu_$MODE" "$@"
		exit 0
	fi

	if [ "$#" = "0" ]; then
		usage
		echo
		error "Must provide at least one desc file"
	fi

	# actual image building
	if [ -z "$OUT" ]; then
		[ "$1" = "-" ] && error "Cannot guess output name from stdin"
		# OUT defaults to first swu name if not set
		OUT="${1%.desc}.swu"
	fi
	OUTDIR=$(dirname -- "$OUT")/.$(basename -- "$OUT" .swu)
	mkdir -p "$OUTDIR"
	OUTDIR=$(realpath -- "$OUTDIR")
	rm -f "$OUTDIR/sw-description-"* "$OUTDIR/used_files"

	main_cwd="$PWD"
	absolutize_file_paths
	# build sw-desc fragments
	for desc; do
		version=""
		install_if=""
		if [ "$desc" = "-" ]; then
			component="stdin"
			desc_file="/proc/self/fd/0"
		else
			[ -e "$desc" ] || error "%s does not exist" "$desc"
			cd "$(dirname -- "$desc")" \
				|| error "cannot enter %s directory" "$desc"
			[ "${desc%.desc}" != "$desc" ] \
				|| info "Warning: %s does not end in .desc, wrong file?" "$desc"
			component="${desc%.desc}"
			component=${component##*/}
			desc_file="./${desc##*/}"
		fi
		. "$desc_file"
		# make key files path absolute after each iteration:
		# this is required if a desc file sets a key path
		absolutize_file_paths
		cd "$main_cwd" || error "Cannot return to %s we were in before" "$main_cwd"
		[ "$#" -gt 1 ] && info "Successfully included %s contents" "$desc"
	done

	[ -z "$FIRST_SWDESC_INIT" ] || [ -n "$FORCE_VERSION" ] \
		|| error "No command could be found in desc files"

	embedded_postinstall_script
	write_sw_desc > "$OUTDIR/sw-description"
	# XXX debian's libconfig is obsolete and does not allow
	# trailing commas at the end of lists (allowed from 1.7.0)
	# probably want to sed these out at some point for compatibility
	# (Note this is only required to run swupdate on debian,
	#  not for image generation)
	mkcpio

	if [ -n "$COPY_USB" ]; then
		info "You have sideloaded containers, copy all these files to USB drive:"
		info "%s" "$(shell_quote "$(realpath "$OUT")") $COPY_USB"
		info
	fi

	cleanup_outdir

	info "Successfully generated %s" "$OUT"
}


# check if sourced: basename $0 should only be mkswu if run directly
[ "$(basename "$0")" != "mkswu" ] && return

mkimage "$@"

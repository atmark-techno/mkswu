#!/bin/sh

PODMAN_ROOT=/var/lib/containers/storage_readonly
CONFDIR=/etc/atmark/containers
FAIL_MISSING=
DRY_RUN=

error() {
	printf "%s\n" "$@" >&2
	exit 1
}

usage() {
	echo "Usage: $0 [options]"
	echo
	echo "Options:"
	echo " --storage <path> Path to podman storage to cleanup"
	echo " --confdir <path> Path to atmark config directory to check in-use image"
	echo "                  If path is empty, all images with a tag are kept"
	echo " --fail-missing   Fail if a configured image is not found"
	echo " --dry-run        Print what would be removed instead of removing"
}

get_pod_infra_container_tag() {
	local infra_container

	infra_container=$(sed -ne 's:^infra_image=::p' "$conf")

	if [ -z "$infra_container" ]; then
		# get default name of the pod infra container... in the target rootfs!
		# XXX find better than parsing help. We can't start a pod to inspect it...
		# note: dry run uses running system instead for easy us
		WRAP="podman run --net=none --rootfs /target"
		[ -n "$DRY_RUN" ] && WRAP=""
		infra_container=$($WRAP podman pod create --help | \
					sed -ne 's/.*infra-image.*default "\([^"]*\)".*/\1/p')
	fi

	if [ -z "$infra_container" ]; then
		printf "%s\n" "Warning: Could not guess podman pod infra container name, continuing without one"
			      "podman_start will require internet to start pods" >&2
		return
	fi

	if ! podman --root "$PODMAN_ROOT" --storage-opt additionalimagestore="" \
			image inspect --format '{{.Id}}' "$infra_container" 2>/dev/null; then
		printf "%s\n" "Warning: pod configured but pod infra container $infra_container was not found!" \
			      "Trying to get it now" >&2
		[ -n "$DRY_RUN" ] && return
		# pull command prints the id of the image it just fetched
		podman --root "$PODMAN_ROOT" --storage-opt additionalimagestore="" \
				pull "$infra_container" || \
			printf "%s\n" "Could not pull infra container: podman_start will require internet" >&2
	fi
}

get_conf_image() {
	local pod
	tag=$(sed -ne 's:^image=::p' "$conf")
	if [ -z "$tag" ]; then
		# maybe a pod?
		grep -qE "^type=pod$" "$conf" &&
			get_pod_infra_container_tag
		return
	fi

	if ! podman --root "$PODMAN_ROOT" \
			--storage-opt additionalimagestore="" \
			image inspect --format '{{.Id}}' \
			"$tag"; then
		[ -n "$FAIL_MISSING" ] || return
		error "image $tag in $conf not found in image store !"
	fi
}

trim_tags() {
	local conf
	[ -n "$CONFDIR" ] || return
	# if no configuration is present, skip this step
	stat "$CONFDIR/"*.conf >/dev/null 2>&1 || return

	# build list of images in use
	: > "$tmpdir/ids"
	for conf in "$CONFDIR/"*.conf; do
		[ -e "$conf" ] || continue
		get_conf_image >> "$tmpdir/ids"
	done

	# untag any unused image
	podman --root "$PODMAN_ROOT" \
		--storage-opt additionalimagestore="" \
		image list \
		--format '{{.Id}}' |
		while read -r id; do
			grep -q -F "$id" "$tmpdir/ids" && continue
			if [ -n "$DRY_RUN" ]; then
				echo "Would remove tag from $id"
				continue
			fi
			podman --root "$PODMAN_ROOT" \
				--storage-opt additionalimagestore="" \
				untag "$id"
		done
}

podman_prune() {
	# skip dry run
	[ -n "$DRY_RUN" ] && return

	podman --root "$PODMAN_ROOT" \
		--storage-opt additionalimagestore="" \
		image prune -f
}

cleanup_images() {
	local tmpdir

	tmpdir=$(mktemp -d -t podman_cleanup.XXXXXX) \
		|| error "Could not create temporary directory"
	trap "rm -rf '$tmpdir'" EXIT

	trim_tags
	podman_prune

	# storage directory cannot be moved if that file is kept around
	# it only contains state data that is safe to delete
	rm -f "$PODMAN_ROOT/libpod/bolt_state.db"
}

while [ $# -ge 1 ]; do
	case "$1" in
	"--storage")
		[ $# -ge 2 ] || error "$1 needs an argument"
		PODMAN_ROOT="$2"
		shift 2
		;;
	"--confdir")
		[ $# -ge 2 ] || error "$1 needs an argument"
		CONFDIR="$2"
		shift 2
		;;
	"--fail-missing")
		FAIL_MISSING=1
		shift
		;;
	"--dry-run")
		DRY_RUN=1
		shift
		;;
	"--")
		shift
		break
		;;
	"-h"|"--help")
		usage
		exit 0
		;;
	*)
		usage
		error "invalid argument: $1"
		;;
	esac
done

cleanup_images

## genkey.sh

Generate a private/public key pair to use for rsa pss signing of files.
generated files:
 - swupdate.key is the private signing key that should be kept private.
 - swupdate.pem should be installed to /etc/swupdate.pem and is used
for verification of sw-description and container images if side-loaded.

Note that encryption does not use this key.


## mkimage.sh

Helper to generate swupdate image.

Configurable options (shell format):

PUBKEY: path to certificate for signing
PRIVKEY: path to key for signing
PRIVKEY_PASS: passphrase for private key, see openssl(1) "Pass Phrase
              Options" for examples (e.g. file:pathname)
ENCRYPT_KEYFILE: encrypt input files if set, generated if does not exist
                 on first use
DESCRIPTION: arbitrary description string. Displayed in verbose swupdate run.
BOOT_SIZE: pad boot image with zeros up to this size (clear env)
           set to blank to keep original file size.
FORCE_VERSION: allow building image with no explicit version set.
POST_ACTION: control behaviour post install
  - not set, empty or "reboot": reboot into new system after updating
  - poweroff: shut system down after install (useful for provisioning)
  - container: if the update has no system component, restart only
               containers without rebooting the system.
	       If system files were updated reboot normally.
  - wait: wait forever after update for an external reboot signal.
          Note further updates will not be installed in this mode:
          the system MUST reboot before installing the next update.


Common options for all helpers:

--version <component> <version>
  We define arbitrary components for swupdate to only install update
  if required.
  - Updates are installed only if version is higher than what is on
    the system, or if not present on the system, except for "boot"
    and "kernel" which are installed if different
  - Components can be defined freely for updates referring to
    containers (container image or files within volumes);
    if an update writes to rootfs then it must be named "base_os"
    (in which case OS is wiped first) or extra_os*/kernel (in
    which case the OS is copied over first)
  - In most case component/version can be skipped (or component set
    to an empty string), in which case the file will always be
    reinstalled so this is not recommended.


Images are then built progressively by calling the following helpers:

swdesc_boot <bootfile>
  Include boot file, version is automatically set from file if not set

swdesc_tar <tar file> [--dest <dest>]
  Extract <tar file> at <path> within new system.
  Destination path must be within /var/app/(rollback/)?volumes
  unless rootfs is targeted (see <component> in Glossary), and defaults
  to / for os versions and /var/app/rollback/volumes otherwise

swdesc_files [--basedir <basedir>] [--dest <dest>] <file> [<more files>]
  Copy files into <dest> (same defaults as swdesc_tar), as they
  are relative to <basedir>
  basedir defaults to the first argument if it is a directory (assumes
  single argument: all the directory content will be extracted to <dest>),
  or the first argument's parent otherwise.

swdesc_command "<cmd>"
  Run command inside new root

swdesc_script <script>
  Run script inside new root

swdesc_exec <file> <command>
  Run command with <file> available as $1 inside the new root
  Note that this is run in the order swdesc is built, so adding
  a swdesc_exec before e.g. base_os will run before the target
  OS is setup and likely not work
  In doubt use swdesc_script unless you need to send data this way.

swdesc_command_nochroot, swdesc_script_nochroot, swdesc_exec_nochroot
  Same as the above but from the currently running os point of view.
  You probably do not need this.

swdesc_embed_container <image archive>
  Include image and load it into storage

swdesc_usb_container <image archive>
  Sign image archive and will look for it on USB drive to
  install with USB update. The image and .sig must be copied
  to the root of the USB drive together with the swu
  Note that podman cannot handle compressed image without storing
  an extra uncompressed copy, so it is best to keep that image
  uncompressed (not a problem for embedding as swupdate does
  the decompressing step)

swdesc_pull_container <image url>
  Pull container from network into storage


## podman_partial_image.sh

Generate image file from tags or image ids.
If a base image/tag is given, remove objects from image file that
were used in base image.


## examples

Sample config files, try from git root:
 ./mkimage.sh -o foo.swu examples/foo.conf

read each .conf file for their requirements (files to pre-create)
all examples expect keys to have been generated before (./genkey.sh),
in default path, and public key must be installed on device to use.


## tests

conf files in the test directory will use internal variables to
disable part or all the scripts, allowing to test specific components
of the system.
Please do not rely on these and ask for supporting features you need!
